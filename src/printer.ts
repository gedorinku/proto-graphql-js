import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb";
import ts from "typescript";
import { Field, Message } from "./types";

export function printSource(fd: FileDescriptorProto, msgs: Message[]): string {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const ast = [
    ts.createImportDeclaration(
      undefined,
      undefined,
      ts.createImportClause(
        undefined,
        ts.createNamedImports([
          ts.createImportSpecifier(
            undefined,
            ts.createIdentifier("objectType")
          ),
        ]),
        false
      ),
      ts.createStringLiteral("@nexus/schema")
    ),
    ...msgs.map(createMessageAST),
  ];
  const file = ts.updateSourceFileNode(
    ts.createSourceFile(
      "generated.ts",
      "",
      ts.ScriptTarget.Latest,
      false,
      ts.ScriptKind.TS
    ),
    ast,
    false
  );
  const result = printer.printFile(file);

  return [
    "// Code generated by protoc-gen-nexus. DO NOT EDIT.",
    `// source: ${fd.getName()}`,
    "",
    result,
  ].join("\n");
}

function createMessageAST(msg: Message): ts.Statement {
  return new MessageAST(msg).build();
}

class MessageAST {
  private readonly msg: Message;

  constructor(msg: Message) {
    this.msg = msg;
  }

  public build(): ts.Statement {
    const { name, description, fields } = this.msg;

    return ts.createFunctionDeclaration(
      undefined,
      [ts.createToken(ts.SyntaxKind.ExportKeyword)],
      undefined,
      `objectType${name}`,
      undefined,
      [],
      undefined,
      ts.createBlock(
        [
          ts.createReturn(
            ts.createCall(ts.createIdentifier("objectType"), undefined, [
              ts.createObjectLiteral(
                [
                  ts.createPropertyAssignment(
                    "name",
                    ts.createStringLiteral(name)
                  ),
                  ts.createPropertyAssignment(
                    "description",
                    ts.createStringLiteral(description)
                  ),
                  // TODO: "description" property
                  ts.createMethod(
                    undefined,
                    undefined,
                    undefined,
                    "definition",
                    undefined,
                    undefined,
                    [
                      ts.createParameter(
                        undefined,
                        undefined,
                        undefined,
                        "t",
                        undefined,
                        undefined,
                        undefined
                      ),
                    ],
                    undefined,
                    ts.createBlock(
                      fields.map((f) => new FieldAST(f).build()),
                      true
                    )
                  ),
                ],
                true
              ),
            ])
          ),
        ],
        true
      )
    );
  }
}

class FieldAST {
  private readonly field: Field;

  constructor(field: Field) {
    this.field = field;
  }

  public build(): ts.Statement {
    const { name } = this.field;

    return ts.createStatement(
      ts.createCall(this.fieldFunction, undefined, [
        ts.createStringLiteral(name),
        this.options,
      ])
    );
  }

  private get fieldFunction(): ts.Expression {
    let left: ts.Expression = ts.createIdentifier("t");

    if (this.field.type.kind === "list") {
      left = ts.createPropertyAccess(left, ts.createIdentifier("list"));
    }

    return ts.createPropertyAccess(
      left,
      ts.createIdentifier(this.nexusTypeName)
    );
  }

  private get nexusTypeName(): string {
    const { type } = this.field;

    switch (type.kind) {
      case "list":
        return "field";
      case "scalar":
        switch (type.type) {
          case "Int":
            return "int";
          case "Float":
            return "float";
          case "String":
            return "string";
          case "Boolean":
            return "boolean";
          case "ID":
            return "id";
          default:
            const _exhaustiveCheck: never = type.type; // eslint-disable-line
            throw "unreachable";
        }
      case "object":
        return "field";
      default:
        const _exhaustiveCheck: never = type; // eslint-disable-line
        throw "unreachable";
    }
  }

  private get options(): ts.ObjectLiteralExpression {
    const { description, type } = this.field;
    const props: ts.ObjectLiteralElementLike[] = [
      ts.createPropertyAssignment(
        "nullable",
        this.field.isNullable() ? ts.createTrue() : ts.createFalse()
      ),
      ts.createPropertyAssignment(
        "description",
        ts.createStringLiteral(description)
      ),
    ];

    if (type.kind === "list") {
      props.push(
        ts.createPropertyAssignment(
          "type",
          ts.createStringLiteral(type.type.type)
        )
      );
    }

    if (type.kind === "object") {
      props.push(
        ts.createPropertyAssignment("type", ts.createStringLiteral(type.type))
      );
    }

    return ts.createObjectLiteral(props, true);
  }
}
