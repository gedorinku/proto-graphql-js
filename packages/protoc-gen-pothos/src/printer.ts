import { collectTypesFromFile, DslFile, GenerationParams } from "@proto-graphql/codegen-core";
import { ProtoFile, ProtoRegistry } from "@proto-graphql/proto-descriptors";
import { code } from "ts-poet";
import { createTypeDslCodes } from "./dslgen";
import { PothosPrinterOptions } from "./dslgen/printers/util";

export function generateFiles(
  registry: ProtoRegistry,
  file: ProtoFile,
  opts: GenerationParams
): { filename: string; content: string }[] {
  const dslFile = new DslFile(file, { ...opts, dsl: "pothos", useTsProto: true });
  const types = collectTypesFromFile(dslFile, registry);
  const printerOpts: PothosPrinterOptions = {
    dsl: "pothos",
    protobuf: "ts-proto",
    // protobuf: opts.useTsProto ? "ts-proto" : opts.useProtobufjs ? "protobufjs" : "google-protobuf",
    importPrefix: opts.importPrefix,
    fileLayout: opts.fileLayout,
    pothos: {
      builderPath: opts.pothosBuilderPath,
    },
  };

  switch (opts.fileLayout) {
    case "proto_file": {
      return [
        {
          filename: dslFile.filename,
          content: printSource(types, file, printerOpts),
        },
      ];
    }
    case "graphql_type": {
      return types.map((t) => ({
        filename: t.filename,
        content: printSource([t], file, printerOpts),
      }));
    }
    /* istanbul ignore next */
    default: {
      const _exhaustiveCheck: never = opts.fileLayout;
      throw "unreachable";
    }
  }
}

function printSource(
  types: ReturnType<typeof collectTypesFromFile>,
  file: ProtoFile,
  opts: PothosPrinterOptions
): string {
  const codes = [...createTypeDslCodes(types, opts)];

  if (codes.length === 0) {
    codes.push(code`export {};`);
  }

  return code`${codes}`.toString({
    prefix: `
      // Code generated by protoc-gen-pothos. DO NOT EDIT.
      // source: ${file.descriptor.getName()}

      /* eslint-disable */
    `,
    dprintOptions: {
      lineWidth: 80,
      indentWidth: 2,
      useTabs: false,
      semiColons: "always",
      quoteStyle: "alwaysDouble",
      quoteProps: "asNeeded",
      newLineKind: "lf",
      useBraces: "whenNotSingleLine",
      bracePosition: "sameLineUnlessHanging",
      singleBodyPosition: "maintain",
      nextControlFlowPosition: "sameLine",
      trailingCommas: "onlyMultiLine",
      operatorPosition: "nextLine",
      preferHanging: false,
      "arrowFunction.useParentheses": "force",
    },
  });
}
