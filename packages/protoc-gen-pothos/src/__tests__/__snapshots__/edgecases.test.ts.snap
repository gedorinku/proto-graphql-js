// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`import squashed union with ts-proto generates pothos DSLs: edgecases/import_squashed_union/pkg1/types_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

import { builder } from \\"../../../../builder\\";
import * as _$testapis$edgecases$import_squashed_union$pkg1$types from \\"./testapis/edgecases/import_squashed_union/pkg1/types\\";
export const Message = builder.objectRef<_$testapis$edgecases$import_squashed_union$pkg1$types.Message>(\\"Message\\");
builder.objectType(Message, {
    name: \\"Message\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$edgecases$import_squashed_union$pkg1$types.Message | {
            $type: string & {};
        }).$type === \\"testapis.edgecases.import_squashed_union.pkg1.Message\\";
    }
});
export type MessageInput_Shape = {
    body: _$testapis$edgecases$import_squashed_union$pkg1$types.Message[\\"body\\"];
};
export const MessageInput = builder.inputRef<MessageInput_Shape>(\\"MessageInput\\");
MessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type SquashedOneofInput_Shape = {
    msg?: MessageInput_Shape | null;
};
export const SquashedOneofInput = builder.inputRef<SquashedOneofInput_Shape>(\\"SquashedOneofInput\\");
SquashedOneofInput.implement({
    fields: t => ({
        msg: t.field({
            type: MessageInput,
            required: false
        })
    })
});
export const SquashedOneof = builder.unionType(\\"SquashedOneof\\", {
    types: [
        Message
    ]
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`import squashed union with ts-proto generates pothos DSLs: edgecases/import_squashed_union/pkg2/types_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

import { builder } from \\"../../../../builder\\";
import * as __$pkg1$types_pb_nexus from \\"../pkg1/types_pb_nexus\\";
import { SquashedOneof } from \\"../pkg1/types_pb_nexus\\";
import { SquashedOneofInput } from \\"../pkg1/types_pb_nexus\\";
import { SquashedOneofInput_Shape } from \\"../pkg1/types_pb_nexus\\";
import * as _$testapis$edgecases$import_squashed_union$pkg1$types from \\"./testapis/edgecases/import_squashed_union/pkg1/types\\";
import * as _$testapis$edgecases$import_squashed_union$pkg2$types from \\"./testapis/edgecases/import_squashed_union/pkg2/types\\";
export const Message = builder.objectRef<_$testapis$edgecases$import_squashed_union$pkg2$types.Message>(\\"Message\\");
builder.objectType(Message, {
    name: \\"Message\\",
    fields: t => ({
        msg: t.field({
            type: SquashedOneof,
            nullable: true,
            resolve: source => {
                const value = source.msg?.msg;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$edgecases$import_squashed_union$pkg2$types.Message | {
            $type: string & {};
        }).$type === \\"testapis.edgecases.import_squashed_union.pkg2.Message\\";
    }
});
export type MessageInput_Shape = {
    msg?: SquashedOneofInput_Shape | null;
};
export const MessageInput = builder.inputRef<MessageInput_Shape>(\\"MessageInput\\");
MessageInput.implement({
    fields: t => ({
        msg: t.field({
            type: SquashedOneofInput,
            required: false
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;
