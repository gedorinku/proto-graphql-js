// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`deprecation with ts-proto generates pothos DSLs: deprecation/deprecation_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$deprecation$deprecation from \\"./testapis/deprecation/deprecation\\";
export const DeprecatedMessage = builder.objectRef<_$testapis$deprecation$deprecation.DeprecatedMessage>(\\"DeprecatedMessage\\");
builder.objectType(DeprecatedMessage, {
    name: \\"DeprecatedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: NotDeprecatedEnum,
            nullable: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\",
            resolve: source => {
                if (source.enum === _$testapis$deprecation$deprecation.NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.DeprecatedMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedMessage\\";
    }
});
export const NotDeprecatedMessage = builder.objectRef<_$testapis$deprecation$deprecation.NotDeprecatedMessage>(\\"NotDeprecatedMessage\\");
builder.objectType(NotDeprecatedMessage, {
    name: \\"NotDeprecatedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: DeprecatedEnum,
            nullable: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\",
            resolve: source => {
                if (source.enum === _$testapis$deprecation$deprecation.DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        }),
        notDeprecatedOneof: t.field({
            type: NotDeprecatedMessageNotDeprecatedOneof,
            nullable: true,
            resolve: source => {
                const value = source.msg1 ?? source.msg2;
                return value;
            }
        }),
        deprecatedOneof: t.field({
            type: NotDeprecatedMessageDeprecatedOneof,
            nullable: true,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.\\",
            resolve: source => {
                const value = source.msg3 ?? source.msg4;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.NotDeprecatedMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.NotDeprecatedMessage\\";
    }
});
export const DeprecatedMessageInnerMessage = builder.objectRef<_$testapis$deprecation$deprecation.DeprecatedMessage_InnerMessage>(\\"DeprecatedMessageInnerMessage\\");
builder.objectType(DeprecatedMessageInnerMessage, {
    name: \\"DeprecatedMessageInnerMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.DeprecatedMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedMessage.InnerMessage\\";
    }
});
export const NotDeprecatedMessageInnerMessage1 = builder.objectRef<_$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage1>(\\"NotDeprecatedMessageInnerMessage1\\");
builder.objectType(NotDeprecatedMessageInnerMessage1, {
    name: \\"NotDeprecatedMessageInnerMessage1\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage1 | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.NotDeprecatedMessage.InnerMessage1\\";
    }
});
export const NotDeprecatedMessageInnerMessage2 = builder.objectRef<_$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage2>(\\"NotDeprecatedMessageInnerMessage2\\");
builder.objectType(NotDeprecatedMessageInnerMessage2, {
    name: \\"NotDeprecatedMessageInnerMessage2\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.NotDeprecatedMessage.InnerMessage2\\";
    }
});
export type DeprecatedMessageInput_Shape = {
    body: _$testapis$deprecation$deprecation.DeprecatedMessage[\\"body\\"];
    enum?: _$testapis$deprecation$deprecation.DeprecatedMessage[\\"enum\\"] | null;
};
export const DeprecatedMessageInput = builder.inputRef<DeprecatedMessageInput_Shape>(\\"DeprecatedMessageInput\\");
DeprecatedMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: NotDeprecatedEnum,
            required: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        })
    })
});
export type NotDeprecatedMessageInput_Shape = {
    body: _$testapis$deprecation$deprecation.NotDeprecatedMessage[\\"body\\"];
    enum?: _$testapis$deprecation$deprecation.NotDeprecatedMessage[\\"enum\\"] | null;
    msg1?: NotDeprecatedMessageInnerMessage1Input_Shape | null;
    msg2?: NotDeprecatedMessageInnerMessage2Input_Shape | null;
    msg3?: NotDeprecatedMessageInnerMessage1Input_Shape | null;
    msg4?: NotDeprecatedMessageInnerMessage2Input_Shape | null;
};
export const NotDeprecatedMessageInput = builder.inputRef<NotDeprecatedMessageInput_Shape>(\\"NotDeprecatedMessageInput\\");
NotDeprecatedMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: DeprecatedEnum,
            required: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\"
        }),
        msg1: t.field({
            type: NotDeprecatedMessageInnerMessage1Input,
            required: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.\\"
        }),
        msg2: t.field({
            type: NotDeprecatedMessageInnerMessage2Input,
            required: false
        }),
        msg3: t.field({
            type: NotDeprecatedMessageInnerMessage1Input,
            required: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.\\"
        }),
        msg4: t.field({
            type: NotDeprecatedMessageInnerMessage2Input,
            required: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.\\"
        })
    })
});
export type DeprecatedMessageInnerMessageInput_Shape = {
    body: _$testapis$deprecation$deprecation.DeprecatedMessage_InnerMessage[\\"body\\"];
};
export const DeprecatedMessageInnerMessageInput = builder.inputRef<DeprecatedMessageInnerMessageInput_Shape>(\\"DeprecatedMessageInnerMessageInput\\");
DeprecatedMessageInnerMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        })
    })
});
export type NotDeprecatedMessageInnerMessage1Input_Shape = {
    body: _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage1[\\"body\\"];
};
export const NotDeprecatedMessageInnerMessage1Input = builder.inputRef<NotDeprecatedMessageInnerMessage1Input_Shape>(\\"NotDeprecatedMessageInnerMessage1Input\\");
NotDeprecatedMessageInnerMessage1Input.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type NotDeprecatedMessageInnerMessage2Input_Shape = {
    body: _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage2[\\"body\\"];
};
export const NotDeprecatedMessageInnerMessage2Input = builder.inputRef<NotDeprecatedMessageInnerMessage2Input_Shape>(\\"NotDeprecatedMessageInnerMessage2Input\\");
NotDeprecatedMessageInnerMessage2Input.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const NotDeprecatedMessageNotDeprecatedOneof = builder.unionType(\\"NotDeprecatedMessageNotDeprecatedOneof\\", {
    types: [
        NotDeprecatedMessageInnerMessage1,
        NotDeprecatedMessageInnerMessage2
    ]
});
export const NotDeprecatedMessageDeprecatedOneof = builder.unionType(\\"NotDeprecatedMessageDeprecatedOneof\\", {
    types: [
        NotDeprecatedMessageInnerMessage1,
        NotDeprecatedMessageInnerMessage2
    ]
});
export const NotDeprecatedEnum = builder.enumType(\\"NotDeprecatedEnum\\", {
    values: {
        NOT_DEPRECATED_FOO: {
            value: 1
        },
        DEPRECATED_BAR: {
            deprecationReason: \\"testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.\\",
            value: 2
        }
    } as const
});
export const DeprecatedEnum = builder.enumType(\\"DeprecatedEnum\\", {
    values: {
        DEPRECATED_BAZ: {
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\",
            value: 1
        },
        DEPRECATED_QUX: {
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\",
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`deprecation with ts-proto generates pothos DSLs: deprecation/file_deprecation_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$deprecation$file_deprecation from \\"./testapis/deprecation/file_deprecation\\";
export const DeprecatedFileMessage = builder.objectRef<_$testapis$deprecation$file_deprecation.DeprecatedFileMessage>(\\"DeprecatedFileMessage\\");
builder.objectType(DeprecatedFileMessage, {
    name: \\"DeprecatedFileMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        }),
        enum: t.field({
            type: DeprecatedFileEnum,
            nullable: true,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\",
            resolve: source => {
                if (source.enum === _$testapis$deprecation$file_deprecation.DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$file_deprecation.DeprecatedFileMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedFileMessage\\";
    }
});
export const DeprecatedFileMessageInnerMessage = builder.objectRef<_$testapis$deprecation$file_deprecation.DeprecatedFileMessage_InnerMessage>(\\"DeprecatedFileMessageInnerMessage\\");
builder.objectType(DeprecatedFileMessageInnerMessage, {
    name: \\"DeprecatedFileMessageInnerMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$file_deprecation.DeprecatedFileMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedFileMessage.InnerMessage\\";
    }
});
export type DeprecatedFileMessageInput_Shape = {
    body: _$testapis$deprecation$file_deprecation.DeprecatedFileMessage[\\"body\\"];
    enum?: _$testapis$deprecation$file_deprecation.DeprecatedFileMessage[\\"enum\\"] | null;
};
export const DeprecatedFileMessageInput = builder.inputRef<DeprecatedFileMessageInput_Shape>(\\"DeprecatedFileMessageInput\\");
DeprecatedFileMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        }),
        enum: t.field({
            type: DeprecatedFileEnum,
            required: false,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        })
    })
});
export type DeprecatedFileMessageInnerMessageInput_Shape = {
    body: _$testapis$deprecation$file_deprecation.DeprecatedFileMessage_InnerMessage[\\"body\\"];
};
export const DeprecatedFileMessageInnerMessageInput = builder.inputRef<DeprecatedFileMessageInnerMessageInput_Shape>(\\"DeprecatedFileMessageInnerMessageInput\\");
DeprecatedFileMessageInnerMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        })
    })
});
export const DeprecatedFileEnum = builder.enumType(\\"DeprecatedFileEnum\\", {
    values: {
        DEPRECATED_FILE_FOO: {
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\",
            value: 1
        },
        DEPRECATED_FILE_BAR: {
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\",
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`empty types with ts-proto generates pothos DSLs: empty_types/empty_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$empty_types$empty from \\"./testapis/empty_types/empty\\";
export const EmptyMessage = builder.objectRef<_$testapis$empty_types$empty.EmptyMessage>(\\"EmptyMessage\\");
builder.objectType(EmptyMessage, {
    name: \\"EmptyMessage\\",
    fields: t => ({
        _: t.field({
            type: \\"Boolean\\",
            nullable: true,
            description: \\"noop field\\",
            resolve() { return true; }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$empty_types$empty.EmptyMessage | {
            $type: string & {};
        }).$type === \\"testapis.empty_types.EmptyMessage\\";
    }
});
export type EmptyMessageInput_Shape = {};
export const EmptyMessageInput = builder.inputRef<EmptyMessageInput_Shape>(\\"EmptyMessageInput\\");
EmptyMessageInput.implement({
    fields: t => ({
        _: t.field({
            type: \\"Boolean\\",
            required: false,
            description: \\"noop field\\"
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`field_behavior with ts-proto generates pothos DSLs: field_behavior/comments_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$field_behavior$comments from \\"./testapis/field_behavior/comments\\";
export const FieldBehaviorComentsMessage = builder.objectRef<_$testapis$field_behavior$comments.FieldBehaviorComentsMessage>(\\"FieldBehaviorComentsMessage\\");
builder.objectType(FieldBehaviorComentsMessage, {
    name: \\"FieldBehaviorComentsMessage\\",
    fields: t => ({
        requiredField: t.field({
            type: FieldBehaviorComentsMessagePost,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredField!;
            }
        }),
        requiredOutputOnlyField: t.field({
            type: FieldBehaviorComentsMessagePost,
            nullable: false,
            description: \\"Required. Output only.\\",
            resolve: source => {
                return source.requiredOutputOnlyField!;
            }
        }),
        outputOnlyRequiredField: t.field({
            type: FieldBehaviorComentsMessagePost,
            nullable: false,
            description: \\"Output only. Required.\\",
            resolve: source => {
                return source.outputOnlyRequiredField!;
            }
        }),
        outputOnlyField: t.expose(\\"outputOnlyField\\", {
            type: FieldBehaviorComentsMessagePost,
            nullable: true,
            description: \\"Output only.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$field_behavior$comments.FieldBehaviorComentsMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.FieldBehaviorComentsMessage\\";
    }
});
export const FieldBehaviorComentsMessagePost = builder.objectRef<_$testapis$field_behavior$comments.FieldBehaviorComentsMessage_Post>(\\"FieldBehaviorComentsMessagePost\\");
builder.objectType(FieldBehaviorComentsMessagePost, {
    name: \\"FieldBehaviorComentsMessagePost\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$field_behavior$comments.FieldBehaviorComentsMessage_Post | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.FieldBehaviorComentsMessage.Post\\";
    }
});
export type FieldBehaviorComentsMessageInput_Shape = {
    requiredField: FieldBehaviorComentsMessagePostInput_Shape;
    requiredInputOnlyField: FieldBehaviorComentsMessagePostInput_Shape;
    inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput_Shape;
    inputOnlyField?: FieldBehaviorComentsMessagePostInput_Shape | null;
};
export const FieldBehaviorComentsMessageInput = builder.inputRef<FieldBehaviorComentsMessageInput_Shape>(\\"FieldBehaviorComentsMessageInput\\");
FieldBehaviorComentsMessageInput.implement({
    fields: t => ({
        requiredField: t.field({
            type: FieldBehaviorComentsMessagePostInput,
            required: true,
            description: \\"Required.\\"
        }),
        requiredInputOnlyField: t.field({
            type: FieldBehaviorComentsMessagePostInput,
            required: true,
            description: \\"Required. Input only.\\"
        }),
        inputOnlyRequiredField: t.field({
            type: FieldBehaviorComentsMessagePostInput,
            required: true,
            description: \\"Input only. Required.\\"
        }),
        inputOnlyField: t.field({
            type: FieldBehaviorComentsMessagePostInput,
            required: false,
            description: \\"Input only.\\"
        })
    })
});
export type FieldBehaviorComentsMessagePostInput_Shape = {
    body: _$testapis$field_behavior$comments.FieldBehaviorComentsMessage_Post[\\"body\\"];
};
export const FieldBehaviorComentsMessagePostInput = builder.inputRef<FieldBehaviorComentsMessagePostInput_Shape>(\\"FieldBehaviorComentsMessagePostInput\\");
FieldBehaviorComentsMessagePostInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`multipkgs with ts-proto generates pothos DSLs: multipkgs/subpkg1/types_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

import { builder } from \\"../../../builder\\";
import * as _$testapis$multipkgs$subpkg1$types from \\"./testapis/multipkgs/subpkg1/types\\";
export const SubpkgMessage = builder.objectRef<_$testapis$multipkgs$subpkg1$types.SubpkgMessage>(\\"SubpkgMessage\\");
builder.objectType(SubpkgMessage, {
    name: \\"SubpkgMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$multipkgs$subpkg1$types.SubpkgMessage | {
            $type: string & {};
        }).$type === \\"testapis.multipkgs.subpkg1.SubpkgMessage\\";
    }
});
export type SubpkgMessageInput_Shape = {
    body: _$testapis$multipkgs$subpkg1$types.SubpkgMessage[\\"body\\"];
};
export const SubpkgMessageInput = builder.inputRef<SubpkgMessageInput_Shape>(\\"SubpkgMessageInput\\");
SubpkgMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const SubpkgEnum = builder.enumType(\\"SubpkgEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`multipkgs with ts-proto generates pothos DSLs: multipkgs/subpkg2/types_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

import { builder } from \\"../../../builder\\";
import * as __$subpkg1$types_pb_nexus from \\"../subpkg1/types_pb_nexus\\";
import { SubpkgMessage } from \\"../subpkg1/types_pb_nexus\\";
import { SubpkgEnum } from \\"../subpkg1/types_pb_nexus\\";
import { SubpkgMessageInput } from \\"../subpkg1/types_pb_nexus\\";
import { SubpkgMessageInput_Shape } from \\"../subpkg1/types_pb_nexus\\";
import * as _$testapis$multipkgs$subpkg1$types from \\"./testapis/multipkgs/subpkg1/types\\";
import * as _$testapis$multipkgs$subpkg2$types from \\"./testapis/multipkgs/subpkg2/types\\";
export const MessageWithSubpkg = builder.objectRef<_$testapis$multipkgs$subpkg2$types.MessageWithSubpkg>(\\"MessageWithSubpkg\\");
builder.objectType(MessageWithSubpkg, {
    name: \\"MessageWithSubpkg\\",
    fields: t => ({
        message: t.expose(\\"message\\", {
            type: SubpkgMessage,
            nullable: true
        }),
        enum: t.field({
            type: SubpkgEnum,
            nullable: true,
            resolve: source => {
                if (source.enum === _$testapis$multipkgs$subpkg1$types.SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$multipkgs$subpkg2$types.MessageWithSubpkg | {
            $type: string & {};
        }).$type === \\"testapis.multipkgs.subpkg1.MessageWithSubpkg\\";
    }
});
export type MessageWithSubpkgInput_Shape = {
    message?: SubpkgMessageInput_Shape | null;
    enum?: _$testapis$multipkgs$subpkg2$types.MessageWithSubpkg[\\"enum\\"] | null;
};
export const MessageWithSubpkgInput = builder.inputRef<MessageWithSubpkgInput_Shape>(\\"MessageWithSubpkgInput\\");
MessageWithSubpkgInput.implement({
    fields: t => ({
        message: t.field({
            type: SubpkgMessageInput,
            required: false
        }),
        enum: t.field({
            type: SubpkgEnum,
            required: false
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`nested protobuf types with ts-proto generates pothos DSLs: nested/nested_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$nested$nested from \\"./testapis/nested/nested\\";
export const ParentMessage = builder.objectRef<_$testapis$nested$nested.ParentMessage>(\\"ParentMessage\\");
builder.objectType(ParentMessage, {
    name: \\"ParentMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        }),
        nested: t.expose(\\"nested\\", {
            type: ParentMessageNestedMessage,
            nullable: true
        }),
        nestedEnum: t.field({
            type: ParentMessageNestedEnum,
            nullable: true,
            resolve: source => {
                if (source.nestedEnum === _$testapis$nested$nested.ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.nestedEnum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$nested$nested.ParentMessage | {
            $type: string & {};
        }).$type === \\"testapis.nested.ParentMessage\\";
    }
});
export const ParentMessageNestedMessage = builder.objectRef<_$testapis$nested$nested.ParentMessage_NestedMessage>(\\"ParentMessageNestedMessage\\");
builder.objectType(ParentMessageNestedMessage, {
    name: \\"ParentMessageNestedMessage\\",
    fields: t => ({
        nestedBody: t.expose(\\"nestedBody\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$nested$nested.ParentMessage_NestedMessage | {
            $type: string & {};
        }).$type === \\"testapis.nested.ParentMessage.NestedMessage\\";
    }
});
export type ParentMessageInput_Shape = {
    body: _$testapis$nested$nested.ParentMessage[\\"body\\"];
    nested?: ParentMessageNestedMessageInput_Shape | null;
    nestedEnum?: _$testapis$nested$nested.ParentMessage[\\"nestedEnum\\"] | null;
};
export const ParentMessageInput = builder.inputRef<ParentMessageInput_Shape>(\\"ParentMessageInput\\");
ParentMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        }),
        nested: t.field({
            type: ParentMessageNestedMessageInput,
            required: false
        }),
        nestedEnum: t.field({
            type: ParentMessageNestedEnum,
            required: false
        })
    })
});
export type ParentMessageNestedMessageInput_Shape = {
    nestedBody: _$testapis$nested$nested.ParentMessage_NestedMessage[\\"nestedBody\\"];
};
export const ParentMessageNestedMessageInput = builder.inputRef<ParentMessageNestedMessageInput_Shape>(\\"ParentMessageNestedMessageInput\\");
ParentMessageNestedMessageInput.implement({
    fields: t => ({
        nestedBody: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const ParentMessageNestedEnum = builder.enumType(\\"ParentMessageNestedEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixIgnoredMessageNotIgnored.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixIgnoredMessageNotIgnored = builder.objectRef<_$testapis$extensions$extensions.IgnoredMessage_NotIgnored>(\\"TestPrefixIgnoredMessageNotIgnored\\");
builder.objectType(TestPrefixIgnoredMessageNotIgnored, {
    name: \\"TestPrefixIgnoredMessageNotIgnored\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.IgnoredMessage_NotIgnored | {
            $type: string & {};
        }).$type === \\"testapis.extensions.IgnoredMessage.NotIgnored\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixIgnoredMessageNotIgnoredInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export type TestPrefixIgnoredMessageNotIgnoredInput_Shape = {
    body: _$testapis$extensions$extensions.IgnoredMessage_NotIgnored[\\"body\\"];
};
export const TestPrefixIgnoredMessageNotIgnoredInput = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput_Shape>(\\"TestPrefixIgnoredMessageNotIgnoredInput\\");
TestPrefixIgnoredMessageNotIgnoredInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixInterfaceMessage.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixInterfaceMessage = builder.interfaceRef<Pick<_$testapis$extensions$extensions.InterfaceMessage, \\"id\\">>(\\"TestPrefixInterfaceMessage\\");
builder.interfaceType(TestPrefixInterfaceMessage, {
    name: \\"TestPrefixInterfaceMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixInterfaceMessageInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export type TestPrefixInterfaceMessageInput_Shape = {
    id: _$testapis$extensions$extensions.InterfaceMessage[\\"id\\"];
};
export const TestPrefixInterfaceMessageInput = builder.inputRef<TestPrefixInterfaceMessageInput_Shape>(\\"TestPrefixInterfaceMessageInput\\");
TestPrefixInterfaceMessageInput.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixInterfaceMessageType.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export const TestPrefixInterfaceMessageType = builder.enumType(\\"TestPrefixInterfaceMessageType\\", {
    values: {
        INNER: {
            value: 1
        },
        INNER2: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedEnum.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export const TestPrefixPrefixedEnum = builder.enumType(\\"TestPrefixPrefixedEnum\\", {
    values: {
        PREFIXED_FOO: {
            value: 1
        },
        PREFIXED_BAR: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessage.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$TestPrefixIgnoredMessageNotIgnored_nexus from \\"./TestPrefixIgnoredMessageNotIgnored.nexus\\";
import * as _$TestPrefixPrefixedEnum_nexus from \\"./TestPrefixPrefixedEnum.nexus\\";
import * as _$TestPrefixPrefixedMessagePartialIgnoreOneof_nexus from \\"./TestPrefixPrefixedMessagePartialIgnoreOneof.nexus\\";
import * as _$TestPrefixPrefixedMessageSquashedMessage_nexus from \\"./TestPrefixPrefixedMessageSquashedMessage.nexus\\";
import * as _$TestPrefixRenamedMessage_nexus from \\"./TestPrefixRenamedMessage.nexus\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessage = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage>(\\"TestPrefixPrefixedMessage\\");
builder.objectType(TestPrefixPrefixedMessage, {
    name: \\"TestPrefixPrefixedMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false,
            description: \\"Output only.\\"
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum,
            nullable: true,
            resolve: source => {
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
                    return null;
                }
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_IGNORED) {
                    throw new Error(\\"PREFIXED_IGNORED is ignored in GraphQL schema\\");
                }
                return source.prefixedEnum;
            }
        }),
        notIgnoredMessage: t.expose(\\"notIgnoredMessage\\", {
            type: TestPrefixIgnoredMessageNotIgnored,
            nullable: true
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessage,
            nullable: true,
            resolve: source => {
                const value = source.squashedMessage?.oneofField ?? source.squashedMessage?.oneofField2;
                return value;
            }
        }),
        thisFieldWasRenamed: t.expose(\\"thisFieldWillBeRenamed\\", {
            type: \\"String\\",
            nullable: false
        }),
        skipResolver: t.expose(\\"skipResolver\\", {
            type: \\"String\\",
            nullable: false
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessage],
            nullable: { list: true, items: false },
            resolve: source => {
                return source.squashedMessages.map(item => {
                    const value = item?.oneofField ?? item?.oneofField2;
                    if (value == null) {
                        throw new Error(\\"squashedMessages should not be null\\");
                    }
                    return value;
                });
            }
        }),
        renamedMessage: t.expose(\\"renamedMessage\\", {
            type: TestPrefixRenamedMessage,
            nullable: true
        }),
        partialIgnoreOneof: t.field({
            type: TestPrefixPrefixedMessagePartialIgnoreOneof,
            nullable: true,
            resolve: source => {
                const value = source.oneofNotIgnoredField;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessage.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessageInnerMessage = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage>(\\"TestPrefixPrefixedMessageInnerMessage\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage, {
    name: \\"TestPrefixPrefixedMessageInnerMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessage2.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessageInnerMessage2 = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage2>(\\"TestPrefixPrefixedMessageInnerMessage2\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2, {
    name: \\"TestPrefixPrefixedMessageInnerMessage2\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage2\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessage2Input.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export type TestPrefixPrefixedMessageInnerMessage2Input_Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessage2Input = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input_Shape>(\\"TestPrefixPrefixedMessageInnerMessage2Input\\");
TestPrefixPrefixedMessageInnerMessage2Input.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessageInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export type TestPrefixPrefixedMessageInnerMessageInput_Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessageInput = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput_Shape>(\\"TestPrefixPrefixedMessageInnerMessageInput\\");
TestPrefixPrefixedMessageInnerMessageInput.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$TestPrefixIgnoredMessageNotIgnoredInput_nexus from \\"./TestPrefixIgnoredMessageNotIgnoredInput.nexus\\";
import * as _$TestPrefixPrefixedEnum_nexus from \\"./TestPrefixPrefixedEnum.nexus\\";
import * as _$TestPrefixPrefixedMessageInnerMessageInput_nexus from \\"./TestPrefixPrefixedMessageInnerMessageInput.nexus\\";
import * as _$TestPrefixPrefixedMessageSquashedMessageInput_nexus from \\"./TestPrefixPrefixedMessageSquashedMessageInput.nexus\\";
import * as _$TestPrefixRenamedMessageInput_nexus from \\"./TestPrefixRenamedMessageInput.nexus\\";
export type TestPrefixPrefixedMessageInput_Shape = {
    body: _$testapis$extensions$extensions.PrefixedMessage[\\"body\\"];
    prefixedEnum?: _$testapis$extensions$extensions.PrefixedMessage[\\"prefixedEnum\\"] | null;
    notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput_Shape | null;
    squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput_Shape | null;
    thisFieldWasRenamed: _$testapis$extensions$extensions.PrefixedMessage[\\"thisFieldWillBeRenamed\\"];
    oneofNotIgnoredField?: TestPrefixPrefixedMessageInnerMessageInput_Shape | null;
    skipResolver: _$testapis$extensions$extensions.PrefixedMessage[\\"skipResolver\\"];
    squashedMessages?: Array<TestPrefixPrefixedMessageSquashedMessageInput_Shape> | null;
    renamedMessage?: TestPrefixRenamedMessageInput_Shape | null;
};
export const TestPrefixPrefixedMessageInput = builder.inputRef<TestPrefixPrefixedMessageInput_Shape>(\\"TestPrefixPrefixedMessageInput\\");
TestPrefixPrefixedMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum,
            required: false
        }),
        notIgnoredMessage: t.field({
            type: TestPrefixIgnoredMessageNotIgnoredInput,
            required: false
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessageInput,
            required: false
        }),
        thisFieldWasRenamed: t.field({
            type: \\"String\\",
            required: true
        }),
        oneofNotIgnoredField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput,
            required: false
        }),
        skipResolver: t.field({
            type: \\"String\\",
            required: true
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessageInput],
            required: { list: false, items: true }
        }),
        renamedMessage: t.field({
            type: TestPrefixRenamedMessageInput,
            required: false
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessagePartialIgnoreOneof.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$TestPrefixPrefixedMessageInnerMessage_nexus from \\"./TestPrefixPrefixedMessageInnerMessage.nexus\\";
export const TestPrefixPrefixedMessagePartialIgnoreOneof = builder.unionType(\\"TestPrefixPrefixedMessagePartialIgnoreOneof\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage
    ]
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageSquashedMessage.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$TestPrefixPrefixedMessageInnerMessage_nexus from \\"./TestPrefixPrefixedMessageInnerMessage.nexus\\";
import * as _$TestPrefixPrefixedMessageInnerMessage2_nexus from \\"./TestPrefixPrefixedMessageInnerMessage2.nexus\\";
export const TestPrefixPrefixedMessageSquashedMessage = builder.unionType(\\"TestPrefixPrefixedMessageSquashedMessage\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage,
        TestPrefixPrefixedMessageInnerMessage2
    ]
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageSquashedMessageInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$TestPrefixPrefixedMessageInnerMessage2Input_nexus from \\"./TestPrefixPrefixedMessageInnerMessage2Input.nexus\\";
import * as _$TestPrefixPrefixedMessageInnerMessageInput_nexus from \\"./TestPrefixPrefixedMessageInnerMessageInput.nexus\\";
export type TestPrefixPrefixedMessageSquashedMessageInput_Shape = {
    oneofField?: TestPrefixPrefixedMessageInnerMessageInput_Shape | null;
    oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input_Shape | null;
};
export const TestPrefixPrefixedMessageSquashedMessageInput = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput_Shape>(\\"TestPrefixPrefixedMessageSquashedMessageInput\\");
TestPrefixPrefixedMessageSquashedMessageInput.implement({
    fields: t => ({
        oneofField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput,
            required: false
        }),
        oneofField2: t.field({
            type: TestPrefixPrefixedMessageInnerMessage2Input,
            required: false
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixRenamedMessage.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixRenamedMessage = builder.objectRef<_$testapis$extensions$extensions.MessageWillRename>(\\"TestPrefixRenamedMessage\\");
builder.objectType(TestPrefixRenamedMessage, {
    name: \\"TestPrefixRenamedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.MessageWillRename | {
            $type: string & {};
        }).$type === \\"testapis.extensions.MessageWillRename\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixRenamedMessageInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
export type TestPrefixRenamedMessageInput_Shape = {
    body: _$testapis$extensions$extensions.MessageWillRename[\\"body\\"];
};
export const TestPrefixRenamedMessageInput = builder.inputRef<TestPrefixRenamedMessageInput_Shape>(\\"TestPrefixRenamedMessageInput\\");
TestPrefixRenamedMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options with ts-proto generates pothos DSLs: extensions/extensions_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessage = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage>(\\"TestPrefixPrefixedMessage\\");
builder.objectType(TestPrefixPrefixedMessage, {
    name: \\"TestPrefixPrefixedMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false,
            description: \\"Output only.\\"
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum,
            nullable: true,
            resolve: source => {
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
                    return null;
                }
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_IGNORED) {
                    throw new Error(\\"PREFIXED_IGNORED is ignored in GraphQL schema\\");
                }
                return source.prefixedEnum;
            }
        }),
        notIgnoredMessage: t.expose(\\"notIgnoredMessage\\", {
            type: TestPrefixIgnoredMessageNotIgnored,
            nullable: true
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessage,
            nullable: true,
            resolve: source => {
                const value = source.squashedMessage?.oneofField ?? source.squashedMessage?.oneofField2;
                return value;
            }
        }),
        thisFieldWasRenamed: t.expose(\\"thisFieldWillBeRenamed\\", {
            type: \\"String\\",
            nullable: false
        }),
        skipResolver: t.expose(\\"skipResolver\\", {
            type: \\"String\\",
            nullable: false
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessage],
            nullable: { list: true, items: false },
            resolve: source => {
                return source.squashedMessages.map(item => {
                    const value = item?.oneofField ?? item?.oneofField2;
                    if (value == null) {
                        throw new Error(\\"squashedMessages should not be null\\");
                    }
                    return value;
                });
            }
        }),
        renamedMessage: t.expose(\\"renamedMessage\\", {
            type: TestPrefixRenamedMessage,
            nullable: true
        }),
        partialIgnoreOneof: t.field({
            type: TestPrefixPrefixedMessagePartialIgnoreOneof,
            nullable: true,
            resolve: source => {
                const value = source.oneofNotIgnoredField;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage\\";
    }
});
export const TestPrefixRenamedMessage = builder.objectRef<_$testapis$extensions$extensions.MessageWillRename>(\\"TestPrefixRenamedMessage\\");
builder.objectType(TestPrefixRenamedMessage, {
    name: \\"TestPrefixRenamedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.MessageWillRename | {
            $type: string & {};
        }).$type === \\"testapis.extensions.MessageWillRename\\";
    }
});
export const TestPrefixPrefixedMessageInnerMessage = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage>(\\"TestPrefixPrefixedMessageInnerMessage\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage, {
    name: \\"TestPrefixPrefixedMessageInnerMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage\\";
    }
});
export const TestPrefixPrefixedMessageInnerMessage2 = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage2>(\\"TestPrefixPrefixedMessageInnerMessage2\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2, {
    name: \\"TestPrefixPrefixedMessageInnerMessage2\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage2\\";
    }
});
export const TestPrefixIgnoredMessageNotIgnored = builder.objectRef<_$testapis$extensions$extensions.IgnoredMessage_NotIgnored>(\\"TestPrefixIgnoredMessageNotIgnored\\");
builder.objectType(TestPrefixIgnoredMessageNotIgnored, {
    name: \\"TestPrefixIgnoredMessageNotIgnored\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.IgnoredMessage_NotIgnored | {
            $type: string & {};
        }).$type === \\"testapis.extensions.IgnoredMessage.NotIgnored\\";
    }
});
export type TestPrefixPrefixedMessageInput_Shape = {
    body: _$testapis$extensions$extensions.PrefixedMessage[\\"body\\"];
    prefixedEnum?: _$testapis$extensions$extensions.PrefixedMessage[\\"prefixedEnum\\"] | null;
    notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput_Shape | null;
    squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput_Shape | null;
    thisFieldWasRenamed: _$testapis$extensions$extensions.PrefixedMessage[\\"thisFieldWillBeRenamed\\"];
    oneofNotIgnoredField?: TestPrefixPrefixedMessageInnerMessageInput_Shape | null;
    skipResolver: _$testapis$extensions$extensions.PrefixedMessage[\\"skipResolver\\"];
    squashedMessages?: Array<TestPrefixPrefixedMessageSquashedMessageInput_Shape> | null;
    renamedMessage?: TestPrefixRenamedMessageInput_Shape | null;
};
export const TestPrefixPrefixedMessageInput = builder.inputRef<TestPrefixPrefixedMessageInput_Shape>(\\"TestPrefixPrefixedMessageInput\\");
TestPrefixPrefixedMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum,
            required: false
        }),
        notIgnoredMessage: t.field({
            type: TestPrefixIgnoredMessageNotIgnoredInput,
            required: false
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessageInput,
            required: false
        }),
        thisFieldWasRenamed: t.field({
            type: \\"String\\",
            required: true
        }),
        oneofNotIgnoredField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput,
            required: false
        }),
        skipResolver: t.field({
            type: \\"String\\",
            required: true
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessageInput],
            required: { list: false, items: true }
        }),
        renamedMessage: t.field({
            type: TestPrefixRenamedMessageInput,
            required: false
        })
    })
});
export type TestPrefixRenamedMessageInput_Shape = {
    body: _$testapis$extensions$extensions.MessageWillRename[\\"body\\"];
};
export const TestPrefixRenamedMessageInput = builder.inputRef<TestPrefixRenamedMessageInput_Shape>(\\"TestPrefixRenamedMessageInput\\");
TestPrefixRenamedMessageInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixInterfaceMessageInput_Shape = {
    id: _$testapis$extensions$extensions.InterfaceMessage[\\"id\\"];
};
export const TestPrefixInterfaceMessageInput = builder.inputRef<TestPrefixInterfaceMessageInput_Shape>(\\"TestPrefixInterfaceMessageInput\\");
TestPrefixInterfaceMessageInput.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixPrefixedMessageInnerMessageInput_Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessageInput = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput_Shape>(\\"TestPrefixPrefixedMessageInnerMessageInput\\");
TestPrefixPrefixedMessageInnerMessageInput.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixPrefixedMessageInnerMessage2Input_Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessage2Input = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input_Shape>(\\"TestPrefixPrefixedMessageInnerMessage2Input\\");
TestPrefixPrefixedMessageInnerMessage2Input.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixPrefixedMessageSquashedMessageInput_Shape = {
    oneofField?: TestPrefixPrefixedMessageInnerMessageInput_Shape | null;
    oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input_Shape | null;
};
export const TestPrefixPrefixedMessageSquashedMessageInput = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput_Shape>(\\"TestPrefixPrefixedMessageSquashedMessageInput\\");
TestPrefixPrefixedMessageSquashedMessageInput.implement({
    fields: t => ({
        oneofField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput,
            required: false
        }),
        oneofField2: t.field({
            type: TestPrefixPrefixedMessageInnerMessage2Input,
            required: false
        })
    })
});
export type TestPrefixIgnoredMessageNotIgnoredInput_Shape = {
    body: _$testapis$extensions$extensions.IgnoredMessage_NotIgnored[\\"body\\"];
};
export const TestPrefixIgnoredMessageNotIgnoredInput = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput_Shape>(\\"TestPrefixIgnoredMessageNotIgnoredInput\\");
TestPrefixIgnoredMessageNotIgnoredInput.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const TestPrefixInterfaceMessage = builder.interfaceRef<Pick<_$testapis$extensions$extensions.InterfaceMessage, \\"id\\">>(\\"TestPrefixInterfaceMessage\\");
builder.interfaceType(TestPrefixInterfaceMessage, {
    name: \\"TestPrefixInterfaceMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        })
    })
});
export const TestPrefixPrefixedMessageSquashedMessage = builder.unionType(\\"TestPrefixPrefixedMessageSquashedMessage\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage,
        TestPrefixPrefixedMessageInnerMessage2
    ]
});
export const TestPrefixPrefixedMessagePartialIgnoreOneof = builder.unionType(\\"TestPrefixPrefixedMessagePartialIgnoreOneof\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage
    ]
});
export const TestPrefixPrefixedEnum = builder.enumType(\\"TestPrefixPrefixedEnum\\", {
    values: {
        PREFIXED_FOO: {
            value: 1
        },
        PREFIXED_BAR: {
            value: 2
        }
    } as const
});
export const TestPrefixInterfaceMessageType = builder.enumType(\\"TestPrefixInterfaceMessageType\\", {
    values: {
        INNER: {
            value: 1
        },
        INNER2: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf custom options with ts-proto generates pothos DSLs: extensions/ignored_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

export {};


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MessageWithEnums.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

import { builder } from \\"../../builder\\";
import * as _$MyEnum_nexus from \\"./MyEnum.nexus\\";
import * as _$MyEnumWithoutUnspecified_nexus from \\"./MyEnumWithoutUnspecified.nexus\\";
import * as _$testapis$enums$enums from \\"./testapis/enums/enums\\";
export const MessageWithEnums = builder.objectRef<_$testapis$enums$enums.MessageWithEnums>(\\"MessageWithEnums\\");
builder.objectType(MessageWithEnums, {
    name: \\"MessageWithEnums\\",
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                if (source.requiredMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    throw new Error(\\"requiredMyEnum is required field. But got unspecified.\\");
                }
                return source.requiredMyEnum;
            }
        }),
        optionalMyEnum: t.field({
            type: MyEnum,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                if (source.optionalMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.optionalMyEnum;
            }
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecified;
            }
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecified;
            }
        }),
        requiredMyEnums: t.field({
            type: [MyEnum],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"requiredMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        optionalMyEnums: t.field({
            type: [MyEnum],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"optionalMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecifieds;
            }
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecifieds;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$enums$enums.MessageWithEnums | {
            $type: string & {};
        }).$type === \\"testapi.enums.MessageWithEnums\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MessageWithEnumsInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

import { builder } from \\"../../builder\\";
import * as _$MyEnum_nexus from \\"./MyEnum.nexus\\";
import * as _$MyEnumWithoutUnspecified_nexus from \\"./MyEnumWithoutUnspecified.nexus\\";
export type MessageWithEnumsInput_Shape = {
    requiredMyEnum: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnum\\"];
    optionalMyEnum?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnum\\"] | null;
    requiredMyEnumWithoutUnspecified: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecified\\"];
    optionalMyEnumWithoutUnspecified?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecified\\"] | null;
    requiredMyEnums: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnums\\"];
    optionalMyEnums?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnums\\"] | null;
    requiredMyEnumWithoutUnspecifieds: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecifieds\\"];
    optionalMyEnumWithoutUnspecifieds?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecifieds\\"] | null;
};
export const MessageWithEnumsInput = builder.inputRef<MessageWithEnumsInput_Shape>(\\"MessageWithEnumsInput\\");
MessageWithEnumsInput.implement({
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnum: t.field({
            type: MyEnum,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnums: t.field({
            type: [MyEnum],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnums: t.field({
            type: [MyEnum],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MyEnum.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

import { builder } from \\"../../builder\\";
export const MyEnum = builder.enumType(\\"MyEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            description: \\"This is Bar.\\",
            value: 2
        },
        BAZ: {
            value: 3
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MyEnumWithoutUnspecified.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

import { builder } from \\"../../builder\\";
export const MyEnumWithoutUnspecified = builder.enumType(\\"MyEnumWithoutUnspecified\\", {
    values: {
        FOO: {
            value: 0
        },
        BAR: {
            value: 1
        },
        BAZ: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf enums with ts-proto generates pothos DSLs: enums/enums_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$enums$enums from \\"./testapis/enums/enums\\";
export const MessageWithEnums = builder.objectRef<_$testapis$enums$enums.MessageWithEnums>(\\"MessageWithEnums\\");
builder.objectType(MessageWithEnums, {
    name: \\"MessageWithEnums\\",
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                if (source.requiredMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    throw new Error(\\"requiredMyEnum is required field. But got unspecified.\\");
                }
                return source.requiredMyEnum;
            }
        }),
        optionalMyEnum: t.field({
            type: MyEnum,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                if (source.optionalMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.optionalMyEnum;
            }
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecified;
            }
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecified;
            }
        }),
        requiredMyEnums: t.field({
            type: [MyEnum],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"requiredMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        optionalMyEnums: t.field({
            type: [MyEnum],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"optionalMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecifieds;
            }
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecifieds;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$enums$enums.MessageWithEnums | {
            $type: string & {};
        }).$type === \\"testapi.enums.MessageWithEnums\\";
    }
});
export type MessageWithEnumsInput_Shape = {
    requiredMyEnum: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnum\\"];
    optionalMyEnum?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnum\\"] | null;
    requiredMyEnumWithoutUnspecified: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecified\\"];
    optionalMyEnumWithoutUnspecified?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecified\\"] | null;
    requiredMyEnums: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnums\\"];
    optionalMyEnums?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnums\\"] | null;
    requiredMyEnumWithoutUnspecifieds: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecifieds\\"];
    optionalMyEnumWithoutUnspecifieds?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecifieds\\"] | null;
};
export const MessageWithEnumsInput = builder.inputRef<MessageWithEnumsInput_Shape>(\\"MessageWithEnumsInput\\");
MessageWithEnumsInput.implement({
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnum: t.field({
            type: MyEnum,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnums: t.field({
            type: [MyEnum],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnums: t.field({
            type: [MyEnum],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export const MyEnum = builder.enumType(\\"MyEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            description: \\"This is Bar.\\",
            value: 2
        },
        BAZ: {
            value: 3
        }
    } as const
});
export const MyEnumWithoutUnspecified = builder.enumType(\\"MyEnumWithoutUnspecified\\", {
    values: {
        FOO: {
            value: 0
        },
        BAR: {
            value: 1
        },
        BAZ: {
            value: 2
        }
    } as const
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage1.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofMemberMessage1 = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage1>(\\"OneofMemberMessage1\\");
builder.objectType(OneofMemberMessage1, {
    name: \\"OneofMemberMessage1\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage1 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage1\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage1Input.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
export type OneofMemberMessage1Input_Shape = {
    body: _$testapis$oneof$oneof.OneofMemberMessage1[\\"body\\"];
};
export const OneofMemberMessage1Input = builder.inputRef<OneofMemberMessage1Input_Shape>(\\"OneofMemberMessage1Input\\");
OneofMemberMessage1Input.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage2.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofMemberMessage2 = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage2>(\\"OneofMemberMessage2\\");
builder.objectType(OneofMemberMessage2, {
    name: \\"OneofMemberMessage2\\",
    fields: t => ({
        imageUrl: t.expose(\\"imageUrl\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage2\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage2Input.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
export type OneofMemberMessage2Input_Shape = {
    imageUrl: _$testapis$oneof$oneof.OneofMemberMessage2[\\"imageUrl\\"];
};
export const OneofMemberMessage2Input = builder.inputRef<OneofMemberMessage2Input_Shape>(\\"OneofMemberMessage2Input\\");
OneofMemberMessage2Input.implement({
    fields: t => ({
        imageUrl: t.field({
            type: \\"String\\",
            required: true
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParent.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$OneofParentOptionalOneofMembers_nexus from \\"./OneofParentOptionalOneofMembers.nexus\\";
import * as _$OneofParentRequiredOneofMembers_nexus from \\"./OneofParentRequiredOneofMembers.nexus\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofParent = builder.objectRef<_$testapis$oneof$oneof.OneofParent>(\\"OneofParent\\");
builder.objectType(OneofParent, {
    name: \\"OneofParent\\",
    fields: t => ({
        normalField: t.expose(\\"normalField\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredOneofMembers: t.field({
            type: OneofParentRequiredOneofMembers,
            nullable: false,
            description: \\"Required. disallow not_set.\\",
            resolve: source => {
                const value = source.requiredMessage1 ?? source.requiredMessage2;
                if (value == null) {
                    throw new Error(\\"requiredOneofMembers should not be null\\");
                }
                return value;
            }
        }),
        optionalOneofMembers: t.field({
            type: OneofParentOptionalOneofMembers,
            nullable: true,
            resolve: source => {
                const value = source.optoinalMessage1 ?? source.optoinalMessage2;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofParent | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofParent\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParentInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$OneofMemberMessage1Input_nexus from \\"./OneofMemberMessage1Input.nexus\\";
import * as _$OneofMemberMessage2Input_nexus from \\"./OneofMemberMessage2Input.nexus\\";
export type OneofParentInput_Shape = {
    normalField: _$testapis$oneof$oneof.OneofParent[\\"normalField\\"];
    requiredMessage1?: OneofMemberMessage1Input_Shape | null;
    requiredMessage2?: OneofMemberMessage2Input_Shape | null;
    optoinalMessage1?: OneofMemberMessage1Input_Shape | null;
    optoinalMessage2?: OneofMemberMessage2Input_Shape | null;
};
export const OneofParentInput = builder.inputRef<OneofParentInput_Shape>(\\"OneofParentInput\\");
OneofParentInput.implement({
    fields: t => ({
        normalField: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredMessage1: t.field({
            type: OneofMemberMessage1Input,
            required: false
        }),
        requiredMessage2: t.field({
            type: OneofMemberMessage2Input,
            required: false
        }),
        optoinalMessage1: t.field({
            type: OneofMemberMessage1Input,
            required: false
        }),
        optoinalMessage2: t.field({
            type: OneofMemberMessage2Input,
            required: false
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParentOptionalOneofMembers.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$OneofMemberMessage1_nexus from \\"./OneofMemberMessage1.nexus\\";
import * as _$OneofMemberMessage2_nexus from \\"./OneofMemberMessage2.nexus\\";
export const OneofParentOptionalOneofMembers = builder.unionType(\\"OneofParentOptionalOneofMembers\\", {
    types: [
        OneofMemberMessage1,
        OneofMemberMessage2
    ]
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParentRequiredOneofMembers.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$OneofMemberMessage1_nexus from \\"./OneofMemberMessage1.nexus\\";
import * as _$OneofMemberMessage2_nexus from \\"./OneofMemberMessage2.nexus\\";
export const OneofParentRequiredOneofMembers = builder.unionType(\\"OneofParentRequiredOneofMembers\\", {
    description: \\"Required. disallow not_set.\\",
    types: [
        OneofMemberMessage1,
        OneofMemberMessage2
    ]
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`protobuf oneof with ts-proto generates pothos DSLs: oneof/oneof_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofParent = builder.objectRef<_$testapis$oneof$oneof.OneofParent>(\\"OneofParent\\");
builder.objectType(OneofParent, {
    name: \\"OneofParent\\",
    fields: t => ({
        normalField: t.expose(\\"normalField\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredOneofMembers: t.field({
            type: OneofParentRequiredOneofMembers,
            nullable: false,
            description: \\"Required. disallow not_set.\\",
            resolve: source => {
                const value = source.requiredMessage1 ?? source.requiredMessage2;
                if (value == null) {
                    throw new Error(\\"requiredOneofMembers should not be null\\");
                }
                return value;
            }
        }),
        optionalOneofMembers: t.field({
            type: OneofParentOptionalOneofMembers,
            nullable: true,
            resolve: source => {
                const value = source.optoinalMessage1 ?? source.optoinalMessage2;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofParent | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofParent\\";
    }
});
export const OneofMemberMessage1 = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage1>(\\"OneofMemberMessage1\\");
builder.objectType(OneofMemberMessage1, {
    name: \\"OneofMemberMessage1\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage1 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage1\\";
    }
});
export const OneofMemberMessage2 = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage2>(\\"OneofMemberMessage2\\");
builder.objectType(OneofMemberMessage2, {
    name: \\"OneofMemberMessage2\\",
    fields: t => ({
        imageUrl: t.expose(\\"imageUrl\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage2\\";
    }
});
export type OneofParentInput_Shape = {
    normalField: _$testapis$oneof$oneof.OneofParent[\\"normalField\\"];
    requiredMessage1?: OneofMemberMessage1Input_Shape | null;
    requiredMessage2?: OneofMemberMessage2Input_Shape | null;
    optoinalMessage1?: OneofMemberMessage1Input_Shape | null;
    optoinalMessage2?: OneofMemberMessage2Input_Shape | null;
};
export const OneofParentInput = builder.inputRef<OneofParentInput_Shape>(\\"OneofParentInput\\");
OneofParentInput.implement({
    fields: t => ({
        normalField: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredMessage1: t.field({
            type: OneofMemberMessage1Input,
            required: false
        }),
        requiredMessage2: t.field({
            type: OneofMemberMessage2Input,
            required: false
        }),
        optoinalMessage1: t.field({
            type: OneofMemberMessage1Input,
            required: false
        }),
        optoinalMessage2: t.field({
            type: OneofMemberMessage2Input,
            required: false
        })
    })
});
export type OneofMemberMessage1Input_Shape = {
    body: _$testapis$oneof$oneof.OneofMemberMessage1[\\"body\\"];
};
export const OneofMemberMessage1Input = builder.inputRef<OneofMemberMessage1Input_Shape>(\\"OneofMemberMessage1Input\\");
OneofMemberMessage1Input.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type OneofMemberMessage2Input_Shape = {
    imageUrl: _$testapis$oneof$oneof.OneofMemberMessage2[\\"imageUrl\\"];
};
export const OneofMemberMessage2Input = builder.inputRef<OneofMemberMessage2Input_Shape>(\\"OneofMemberMessage2Input\\");
OneofMemberMessage2Input.implement({
    fields: t => ({
        imageUrl: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const OneofParentRequiredOneofMembers = builder.unionType(\\"OneofParentRequiredOneofMembers\\", {
    description: \\"Required. disallow not_set.\\",
    types: [
        OneofMemberMessage1,
        OneofMemberMessage2
    ]
});
export const OneofParentOptionalOneofMembers = builder.unionType(\\"OneofParentOptionalOneofMembers\\", {
    types: [
        OneofMemberMessage1,
        OneofMemberMessage2
    ]
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/Message.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

import { builder } from \\"../../builder\\";
import * as _$Primitives_nexus from \\"./Primitives.nexus\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Message = builder.objectRef<_$testapis$primitives$primitives.Message>(\\"Message\\");
builder.objectType(Message, {
    name: \\"Message\\",
    fields: t => ({
        requiredPrimitives: t.field({
            type: Primitives,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitives!;
            }
        }),
        optionalPrimitives: t.expose(\\"optionalPrimitives\\", {
            type: Primitives,
            nullable: true,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [Primitives],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitivesList!;
            }
        }),
        optionalPrimitivesList: t.expose(\\"optionalPrimitivesList\\", {
            type: [Primitives],
            nullable: { list: true, items: false },
            description: \\"Optional.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Message | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Message\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/MessageInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

import { builder } from \\"../../builder\\";
import * as _$PrimitivesInput_nexus from \\"./PrimitivesInput.nexus\\";
export type MessageInput_Shape = {
    requiredPrimitives: PrimitivesInput_Shape;
    optionalPrimitives?: PrimitivesInput_Shape | null;
    requiredPrimitivesList: Array<PrimitivesInput_Shape>;
    optionalPrimitivesList?: Array<PrimitivesInput_Shape> | null;
};
export const MessageInput = builder.inputRef<MessageInput_Shape>(\\"MessageInput\\");
MessageInput.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesInput,
            required: true,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesInput,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesInput],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesInput],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/Primitives.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Primitives = builder.objectRef<_$testapis$primitives$primitives.Primitives>(\\"Primitives\\");
builder.objectType(Primitives, {
    name: \\"Primitives\\",
    fields: t => ({
        requiredDoubleValue: t.expose(\\"requiredDoubleValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredFloatValue: t.expose(\\"requiredFloatValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredInt32Value: t.expose(\\"requiredInt32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredInt64Value: t.expose(\\"requiredInt64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredUint32Value: t.expose(\\"requiredUint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredUint64Value: t.expose(\\"requiredUint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSint32Value: t.expose(\\"requiredSint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSint64Value: t.expose(\\"requiredSint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredFixed32Value: t.expose(\\"requiredFixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredFixed64Value: t.expose(\\"requiredFixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSfixed32Value: t.expose(\\"requiredSfixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSfixed64Value: t.expose(\\"requiredSfixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredBoolValue: t.expose(\\"requiredBoolValue\\", {
            type: \\"Boolean\\",
            nullable: false
        }),
        requiredStringValue: t.expose(\\"requiredStringValue\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredDoubleValues: t.expose(\\"requiredDoubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredFloatValues: t.expose(\\"requiredFloatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt32Values: t.expose(\\"requiredInt32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt64Values: t.expose(\\"requiredInt64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint32Values: t.expose(\\"requiredUint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint64Values: t.expose(\\"requiredUint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint32Values: t.expose(\\"requiredSint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint64Values: t.expose(\\"requiredSint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed32Values: t.expose(\\"requiredFixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed64Values: t.expose(\\"requiredFixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed32Values: t.expose(\\"requiredSfixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed64Values: t.expose(\\"requiredSfixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredBoolValues: t.expose(\\"requiredBoolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: false, items: false }
        }),
        requiredStringValues: t.expose(\\"requiredStringValues\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Primitives | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Primitives\\";
    }
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/PrimitivesInput.nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

import { builder } from \\"../../builder\\";
export type PrimitivesInput_Shape = {
    requiredDoubleValue: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"];
    requiredFloatValue: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"];
    requiredInt32Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"];
    requiredInt64Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"];
    requiredUint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"];
    requiredUint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"];
    requiredSint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"];
    requiredSint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"];
    requiredFixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"];
    requiredFixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"];
    requiredSfixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"];
    requiredSfixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"];
    requiredBoolValue: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"];
    requiredStringValue: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"];
    requiredDoubleValues: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"];
    requiredFloatValues: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"];
    requiredInt32Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"];
    requiredInt64Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"];
    requiredUint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"];
    requiredUint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"];
    requiredSint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"];
    requiredSint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"];
    requiredFixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"];
    requiredFixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"];
    requiredSfixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"];
    requiredSfixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"];
    requiredBoolValues: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"];
    requiredStringValues: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"];
};
export const PrimitivesInput = builder.inputRef<PrimitivesInput_Shape>(\\"PrimitivesInput\\");
PrimitivesInput.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: true
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: true, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`simple proto file generates pothos DSLs with partial inputs: primitives/primitives_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Message = builder.objectRef<_$testapis$primitives$primitives.Message>(\\"Message\\");
builder.objectType(Message, {
    name: \\"Message\\",
    fields: t => ({
        requiredPrimitives: t.field({
            type: Primitives,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitives!;
            }
        }),
        optionalPrimitives: t.expose(\\"optionalPrimitives\\", {
            type: Primitives,
            nullable: true,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [Primitives],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitivesList!;
            }
        }),
        optionalPrimitivesList: t.expose(\\"optionalPrimitivesList\\", {
            type: [Primitives],
            nullable: { list: true, items: false },
            description: \\"Optional.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Message | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Message\\";
    }
});
export const Primitives = builder.objectRef<_$testapis$primitives$primitives.Primitives>(\\"Primitives\\");
builder.objectType(Primitives, {
    name: \\"Primitives\\",
    fields: t => ({
        requiredDoubleValue: t.expose(\\"requiredDoubleValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredFloatValue: t.expose(\\"requiredFloatValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredInt32Value: t.expose(\\"requiredInt32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredInt64Value: t.expose(\\"requiredInt64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredUint32Value: t.expose(\\"requiredUint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredUint64Value: t.expose(\\"requiredUint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSint32Value: t.expose(\\"requiredSint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSint64Value: t.expose(\\"requiredSint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredFixed32Value: t.expose(\\"requiredFixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredFixed64Value: t.expose(\\"requiredFixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSfixed32Value: t.expose(\\"requiredSfixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSfixed64Value: t.expose(\\"requiredSfixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredBoolValue: t.expose(\\"requiredBoolValue\\", {
            type: \\"Boolean\\",
            nullable: false
        }),
        requiredStringValue: t.expose(\\"requiredStringValue\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredDoubleValues: t.expose(\\"requiredDoubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredFloatValues: t.expose(\\"requiredFloatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt32Values: t.expose(\\"requiredInt32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt64Values: t.expose(\\"requiredInt64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint32Values: t.expose(\\"requiredUint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint64Values: t.expose(\\"requiredUint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint32Values: t.expose(\\"requiredSint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint64Values: t.expose(\\"requiredSint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed32Values: t.expose(\\"requiredFixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed64Values: t.expose(\\"requiredFixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed32Values: t.expose(\\"requiredSfixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed64Values: t.expose(\\"requiredSfixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredBoolValues: t.expose(\\"requiredBoolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: false, items: false }
        }),
        requiredStringValues: t.expose(\\"requiredStringValues\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Primitives | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Primitives\\";
    }
});
export type MessageInput_Shape = {
    requiredPrimitives: PrimitivesInput_Shape;
    optionalPrimitives?: PrimitivesInput_Shape | null;
    requiredPrimitivesList: Array<PrimitivesInput_Shape>;
    optionalPrimitivesList?: Array<PrimitivesInput_Shape> | null;
};
export const MessageInput = builder.inputRef<MessageInput_Shape>(\\"MessageInput\\");
MessageInput.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesInput,
            required: true,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesInput,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesInput],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesInput],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export type MessagePartialInput_Shape = {
    requiredPrimitives?: PrimitivesPartialInput_Shape | null;
    optionalPrimitives?: PrimitivesPartialInput_Shape | null;
    requiredPrimitivesList?: Array<PrimitivesPartialInput_Shape> | null;
    optionalPrimitivesList?: Array<PrimitivesPartialInput_Shape> | null;
};
export const MessagePartialInput = builder.inputRef<MessagePartialInput_Shape>(\\"MessagePartialInput\\");
MessagePartialInput.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesPartialInput,
            required: false,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesPartialInput,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesPartialInput],
            required: { list: false, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesPartialInput],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export type PrimitivesInput_Shape = {
    requiredDoubleValue: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"];
    requiredFloatValue: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"];
    requiredInt32Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"];
    requiredInt64Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"];
    requiredUint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"];
    requiredUint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"];
    requiredSint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"];
    requiredSint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"];
    requiredFixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"];
    requiredFixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"];
    requiredSfixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"];
    requiredSfixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"];
    requiredBoolValue: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"];
    requiredStringValue: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"];
    requiredDoubleValues: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"];
    requiredFloatValues: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"];
    requiredInt32Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"];
    requiredInt64Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"];
    requiredUint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"];
    requiredUint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"];
    requiredSint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"];
    requiredSint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"];
    requiredFixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"];
    requiredFixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"];
    requiredSfixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"];
    requiredSfixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"];
    requiredBoolValues: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"];
    requiredStringValues: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"];
};
export const PrimitivesInput = builder.inputRef<PrimitivesInput_Shape>(\\"PrimitivesInput\\");
PrimitivesInput.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: true
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: true, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        })
    })
});
export type PrimitivesPartialInput_Shape = {
    requiredDoubleValue?: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"] | null;
    requiredFloatValue?: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"] | null;
    requiredInt32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"] | null;
    requiredInt64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"] | null;
    requiredUint32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"] | null;
    requiredUint64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"] | null;
    requiredSint32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"] | null;
    requiredSint64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"] | null;
    requiredFixed32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"] | null;
    requiredFixed64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"] | null;
    requiredSfixed32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"] | null;
    requiredSfixed64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"] | null;
    requiredBoolValue?: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"] | null;
    requiredStringValue?: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"] | null;
    requiredDoubleValues?: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"] | null;
    requiredFloatValues?: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"] | null;
    requiredInt32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"] | null;
    requiredInt64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"] | null;
    requiredUint32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"] | null;
    requiredUint64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"] | null;
    requiredSint32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"] | null;
    requiredSint64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"] | null;
    requiredFixed32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"] | null;
    requiredFixed64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"] | null;
    requiredSfixed32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"] | null;
    requiredSfixed64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"] | null;
    requiredBoolValues?: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"] | null;
    requiredStringValues?: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"] | null;
};
export const PrimitivesPartialInput = builder.inputRef<PrimitivesPartialInput_Shape>(\\"PrimitivesPartialInput\\");
PrimitivesPartialInput.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: false
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: false, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`simple proto file with ts-proto generates pothos DSLs: primitives/primitives_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Message = builder.objectRef<_$testapis$primitives$primitives.Message>(\\"Message\\");
builder.objectType(Message, {
    name: \\"Message\\",
    fields: t => ({
        requiredPrimitives: t.field({
            type: Primitives,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitives!;
            }
        }),
        optionalPrimitives: t.expose(\\"optionalPrimitives\\", {
            type: Primitives,
            nullable: true,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [Primitives],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitivesList!;
            }
        }),
        optionalPrimitivesList: t.expose(\\"optionalPrimitivesList\\", {
            type: [Primitives],
            nullable: { list: true, items: false },
            description: \\"Optional.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Message | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Message\\";
    }
});
export const Primitives = builder.objectRef<_$testapis$primitives$primitives.Primitives>(\\"Primitives\\");
builder.objectType(Primitives, {
    name: \\"Primitives\\",
    fields: t => ({
        requiredDoubleValue: t.expose(\\"requiredDoubleValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredFloatValue: t.expose(\\"requiredFloatValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredInt32Value: t.expose(\\"requiredInt32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredInt64Value: t.expose(\\"requiredInt64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredUint32Value: t.expose(\\"requiredUint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredUint64Value: t.expose(\\"requiredUint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSint32Value: t.expose(\\"requiredSint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSint64Value: t.expose(\\"requiredSint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredFixed32Value: t.expose(\\"requiredFixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredFixed64Value: t.expose(\\"requiredFixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSfixed32Value: t.expose(\\"requiredSfixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSfixed64Value: t.expose(\\"requiredSfixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredBoolValue: t.expose(\\"requiredBoolValue\\", {
            type: \\"Boolean\\",
            nullable: false
        }),
        requiredStringValue: t.expose(\\"requiredStringValue\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredDoubleValues: t.expose(\\"requiredDoubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredFloatValues: t.expose(\\"requiredFloatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt32Values: t.expose(\\"requiredInt32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt64Values: t.expose(\\"requiredInt64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint32Values: t.expose(\\"requiredUint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint64Values: t.expose(\\"requiredUint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint32Values: t.expose(\\"requiredSint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint64Values: t.expose(\\"requiredSint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed32Values: t.expose(\\"requiredFixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed64Values: t.expose(\\"requiredFixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed32Values: t.expose(\\"requiredSfixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed64Values: t.expose(\\"requiredSfixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredBoolValues: t.expose(\\"requiredBoolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: false, items: false }
        }),
        requiredStringValues: t.expose(\\"requiredStringValues\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Primitives | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Primitives\\";
    }
});
export type MessageInput_Shape = {
    requiredPrimitives: PrimitivesInput_Shape;
    optionalPrimitives?: PrimitivesInput_Shape | null;
    requiredPrimitivesList: Array<PrimitivesInput_Shape>;
    optionalPrimitivesList?: Array<PrimitivesInput_Shape> | null;
};
export const MessageInput = builder.inputRef<MessageInput_Shape>(\\"MessageInput\\");
MessageInput.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesInput,
            required: true,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesInput,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesInput],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesInput],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export type PrimitivesInput_Shape = {
    requiredDoubleValue: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"];
    requiredFloatValue: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"];
    requiredInt32Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"];
    requiredInt64Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"];
    requiredUint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"];
    requiredUint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"];
    requiredSint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"];
    requiredSint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"];
    requiredFixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"];
    requiredFixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"];
    requiredSfixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"];
    requiredSfixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"];
    requiredBoolValue: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"];
    requiredStringValue: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"];
    requiredDoubleValues: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"];
    requiredFloatValues: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"];
    requiredInt32Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"];
    requiredInt64Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"];
    requiredUint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"];
    requiredUint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"];
    requiredSint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"];
    requiredSint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"];
    requiredFixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"];
    requiredFixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"];
    requiredSfixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"];
    requiredSfixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"];
    requiredBoolValues: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"];
    requiredStringValues: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"];
};
export const PrimitivesInput = builder.inputRef<PrimitivesInput_Shape>(\\"PrimitivesInput\\");
PrimitivesInput.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: true
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: true, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;

exports[`well-known protobuf types with ts-proto generates pothos DSLs: wktypes/well_known_types_pb_nexus.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

import { builder } from \\"../../builder\\";
import * as _$testapis$wktypes$well_known_types from \\"./testapis/wktypes/well_known_types\\";
export const Message = builder.objectRef<_$testapis$wktypes$well_known_types.Message>(\\"Message\\");
builder.objectType(Message, {
    name: \\"Message\\",
    fields: t => ({
        timestamp: t.expose(\\"timestamp\\", {
            type: \\"DateTime\\",
            nullable: true
        }),
        int32Value: t.expose(\\"int32Value\\", {
            type: \\"Int\\",
            nullable: true
        }),
        int64Value: t.expose(\\"int64Value\\", {
            type: \\"String\\",
            nullable: true
        }),
        uint32Value: t.expose(\\"uint32Value\\", {
            type: \\"Int\\",
            nullable: true
        }),
        uint64Value: t.expose(\\"uint64Value\\", {
            type: \\"String\\",
            nullable: true
        }),
        floatValue: t.expose(\\"floatValue\\", {
            type: \\"Float\\",
            nullable: true
        }),
        doubleValue: t.expose(\\"doubleValue\\", {
            type: \\"Float\\",
            nullable: true
        }),
        boolValue: t.expose(\\"boolValue\\", {
            type: \\"Boolean\\",
            nullable: true
        }),
        stringValue: t.expose(\\"stringValue\\", {
            type: \\"String\\",
            nullable: true
        }),
        timestamps: t.expose(\\"timestamps\\", {
            type: [\\"DateTime\\"],
            nullable: { list: true, items: false }
        }),
        int32Values: t.expose(\\"int32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: true, items: false }
        }),
        int64Values: t.expose(\\"int64Values\\", {
            type: [\\"String\\"],
            nullable: { list: true, items: false }
        }),
        uint32Values: t.expose(\\"uint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: true, items: false }
        }),
        uint64Values: t.expose(\\"uint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: true, items: false }
        }),
        floatValues: t.expose(\\"floatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: true, items: false }
        }),
        doubleValues: t.expose(\\"doubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: true, items: false }
        }),
        boolValues: t.expose(\\"boolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: true, items: false }
        }),
        stringValues: t.expose(\\"stringValues\\", {
            type: [\\"String\\"],
            nullable: { list: true, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$wktypes$well_known_types.Message | {
            $type: string & {};
        }).$type === \\"testapis.wktypes.Message\\";
    }
});
export type MessageInput_Shape = {
    timestamp?: _$testapis$wktypes$well_known_types.Message[\\"timestamp\\"] | null;
    int32Value?: _$testapis$wktypes$well_known_types.Message[\\"int32Value\\"] | null;
    int64Value?: _$testapis$wktypes$well_known_types.Message[\\"int64Value\\"] | null;
    uint32Value?: _$testapis$wktypes$well_known_types.Message[\\"uint32Value\\"] | null;
    uint64Value?: _$testapis$wktypes$well_known_types.Message[\\"uint64Value\\"] | null;
    floatValue?: _$testapis$wktypes$well_known_types.Message[\\"floatValue\\"] | null;
    doubleValue?: _$testapis$wktypes$well_known_types.Message[\\"doubleValue\\"] | null;
    boolValue?: _$testapis$wktypes$well_known_types.Message[\\"boolValue\\"] | null;
    stringValue?: _$testapis$wktypes$well_known_types.Message[\\"stringValue\\"] | null;
    timestamps?: _$testapis$wktypes$well_known_types.Message[\\"timestamps\\"] | null;
    int32Values?: _$testapis$wktypes$well_known_types.Message[\\"int32Values\\"] | null;
    int64Values?: _$testapis$wktypes$well_known_types.Message[\\"int64Values\\"] | null;
    uint32Values?: _$testapis$wktypes$well_known_types.Message[\\"uint32Values\\"] | null;
    uint64Values?: _$testapis$wktypes$well_known_types.Message[\\"uint64Values\\"] | null;
    floatValues?: _$testapis$wktypes$well_known_types.Message[\\"floatValues\\"] | null;
    doubleValues?: _$testapis$wktypes$well_known_types.Message[\\"doubleValues\\"] | null;
    boolValues?: _$testapis$wktypes$well_known_types.Message[\\"boolValues\\"] | null;
    stringValues?: _$testapis$wktypes$well_known_types.Message[\\"stringValues\\"] | null;
};
export const MessageInput = builder.inputRef<MessageInput_Shape>(\\"MessageInput\\");
MessageInput.implement({
    fields: t => ({
        timestamp: t.field({
            type: \\"DateTime\\",
            required: false
        }),
        int32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        int64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        uint32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        uint64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        floatValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        doubleValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        boolValue: t.field({
            type: \\"Boolean\\",
            required: false
        }),
        stringValue: t.field({
            type: \\"String\\",
            required: false
        }),
        timestamps: t.field({
            type: [\\"DateTime\\"],
            required: { list: false, items: true }
        }),
        int32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        int64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        uint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        uint64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        floatValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        doubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        boolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: false, items: true }
        }),
        stringValues: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        })
    })
});


type _RemoveTypeRecursively<T> = (
  T extends Array<infer U>
    ? Array<_RemoveTypeRecursively<U>>
    : T extends Record<string, any>
    ? Omit<{ [K in keyof T]: _RemoveTypeRecursively<T[K]> }, \\"$type\\">
    : T
) extends infer P
  ? { [K in keyof P]: P[K] }
  : never;
"
`;
