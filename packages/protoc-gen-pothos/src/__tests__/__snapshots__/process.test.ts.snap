// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`deprecation with ts-proto generates pothos DSLs: deprecation/deprecation.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$deprecation$deprecation from \\"./testapis/deprecation/deprecation\\";
export const DeprecatedMessage$Ref = builder.objectRef<_$testapis$deprecation$deprecation.DeprecatedMessage>(\\"DeprecatedMessage\\");
builder.objectType(DeprecatedMessage$Ref, {
    name: \\"DeprecatedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: NotDeprecatedEnum$Ref,
            nullable: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\",
            resolve: source => {
                if (source.enum === _$testapis$deprecation$deprecation.NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.DeprecatedMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedMessage\\";
    }
});
export const NotDeprecatedMessage$Ref = builder.objectRef<_$testapis$deprecation$deprecation.NotDeprecatedMessage>(\\"NotDeprecatedMessage\\");
builder.objectType(NotDeprecatedMessage$Ref, {
    name: \\"NotDeprecatedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: DeprecatedEnum$Ref,
            nullable: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\",
            resolve: source => {
                if (source.enum === _$testapis$deprecation$deprecation.DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        }),
        notDeprecatedOneof: t.field({
            type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
            nullable: true,
            resolve: source => {
                const value = source.msg1 ?? source.msg2;
                return value;
            }
        }),
        deprecatedOneof: t.field({
            type: NotDeprecatedMessageDeprecatedOneof$Ref,
            nullable: true,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.\\",
            resolve: source => {
                const value = source.msg3 ?? source.msg4;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.NotDeprecatedMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.NotDeprecatedMessage\\";
    }
});
export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<_$testapis$deprecation$deprecation.DeprecatedMessage_InnerMessage>(\\"DeprecatedMessageInnerMessage\\");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
    name: \\"DeprecatedMessageInnerMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.DeprecatedMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedMessage.InnerMessage\\";
    }
});
export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<_$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage1>(\\"NotDeprecatedMessageInnerMessage1\\");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
    name: \\"NotDeprecatedMessageInnerMessage1\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage1 | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.NotDeprecatedMessage.InnerMessage1\\";
    }
});
export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<_$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage2>(\\"NotDeprecatedMessageInnerMessage2\\");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
    name: \\"NotDeprecatedMessageInnerMessage2\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.NotDeprecatedMessage.InnerMessage2\\";
    }
});
export type DeprecatedMessageInput$Shape = {
    body: _$testapis$deprecation$deprecation.DeprecatedMessage[\\"body\\"];
    enum?: _$testapis$deprecation$deprecation.DeprecatedMessage[\\"enum\\"] | null;
};
export const DeprecatedMessageInput$Ref = builder.inputRef<DeprecatedMessageInput$Shape>(\\"DeprecatedMessageInput\\");
DeprecatedMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: NotDeprecatedEnum$Ref,
            required: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        })
    })
});
export type NotDeprecatedMessageInput$Shape = {
    body: _$testapis$deprecation$deprecation.NotDeprecatedMessage[\\"body\\"];
    enum?: _$testapis$deprecation$deprecation.NotDeprecatedMessage[\\"enum\\"] | null;
    msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
    msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
    msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
    msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};
export const NotDeprecatedMessageInput$Ref = builder.inputRef<NotDeprecatedMessageInput$Shape>(\\"NotDeprecatedMessageInput\\");
NotDeprecatedMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.\\"
        }),
        enum: t.field({
            type: DeprecatedEnum$Ref,
            required: false,
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\"
        }),
        msg1: t.field({
            type: NotDeprecatedMessageInnerMessage1Input$Ref,
            required: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.\\"
        }),
        msg2: t.field({
            type: NotDeprecatedMessageInnerMessage2Input$Ref,
            required: false
        }),
        msg3: t.field({
            type: NotDeprecatedMessageInnerMessage1Input$Ref,
            required: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.\\"
        }),
        msg4: t.field({
            type: NotDeprecatedMessageInnerMessage2Input$Ref,
            required: false,
            deprecationReason: \\"testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.\\"
        })
    })
});
export type DeprecatedMessageInnerMessageInput$Shape = {
    body: _$testapis$deprecation$deprecation.DeprecatedMessage_InnerMessage[\\"body\\"];
};
export const DeprecatedMessageInnerMessageInput$Ref = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(\\"DeprecatedMessageInnerMessageInput\\");
DeprecatedMessageInnerMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.\\"
        })
    })
});
export type NotDeprecatedMessageInnerMessage1Input$Shape = {
    body: _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage1[\\"body\\"];
};
export const NotDeprecatedMessageInnerMessage1Input$Ref = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(\\"NotDeprecatedMessageInnerMessage1Input\\");
NotDeprecatedMessageInnerMessage1Input$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type NotDeprecatedMessageInnerMessage2Input$Shape = {
    body: _$testapis$deprecation$deprecation.NotDeprecatedMessage_InnerMessage2[\\"body\\"];
};
export const NotDeprecatedMessageInnerMessage2Input$Ref = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(\\"NotDeprecatedMessageInnerMessage2Input\\");
NotDeprecatedMessageInnerMessage2Input$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(\\"NotDeprecatedMessageNotDeprecatedOneof\\", {
    types: [
        NotDeprecatedMessageInnerMessage1$Ref,
        NotDeprecatedMessageInnerMessage2$Ref
    ]
});
export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(\\"NotDeprecatedMessageDeprecatedOneof\\", {
    types: [
        NotDeprecatedMessageInnerMessage1$Ref,
        NotDeprecatedMessageInnerMessage2$Ref
    ]
});
export const NotDeprecatedEnum$Ref = builder.enumType(\\"NotDeprecatedEnum\\", {
    values: {
        NOT_DEPRECATED_FOO: {
            value: 1
        },
        DEPRECATED_BAR: {
            deprecationReason: \\"testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.\\",
            value: 2
        }
    } as const
});
export const DeprecatedEnum$Ref = builder.enumType(\\"DeprecatedEnum\\", {
    values: {
        DEPRECATED_BAZ: {
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\",
            value: 1
        },
        DEPRECATED_QUX: {
            deprecationReason: \\"testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.\\",
            value: 2
        }
    } as const
});
"
`;

exports[`deprecation with ts-proto generates pothos DSLs: deprecation/file_deprecation.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$deprecation$file_deprecation from \\"./testapis/deprecation/file_deprecation\\";
export const DeprecatedFileMessage$Ref = builder.objectRef<_$testapis$deprecation$file_deprecation.DeprecatedFileMessage>(\\"DeprecatedFileMessage\\");
builder.objectType(DeprecatedFileMessage$Ref, {
    name: \\"DeprecatedFileMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        }),
        enum: t.field({
            type: DeprecatedFileEnum$Ref,
            nullable: true,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\",
            resolve: source => {
                if (source.enum === _$testapis$deprecation$file_deprecation.DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$file_deprecation.DeprecatedFileMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedFileMessage\\";
    }
});
export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<_$testapis$deprecation$file_deprecation.DeprecatedFileMessage_InnerMessage>(\\"DeprecatedFileMessageInnerMessage\\");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
    name: \\"DeprecatedFileMessageInnerMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$deprecation$file_deprecation.DeprecatedFileMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.DeprecatedFileMessage.InnerMessage\\";
    }
});
export type DeprecatedFileMessageInput$Shape = {
    body: _$testapis$deprecation$file_deprecation.DeprecatedFileMessage[\\"body\\"];
    enum?: _$testapis$deprecation$file_deprecation.DeprecatedFileMessage[\\"enum\\"] | null;
};
export const DeprecatedFileMessageInput$Ref = builder.inputRef<DeprecatedFileMessageInput$Shape>(\\"DeprecatedFileMessageInput\\");
DeprecatedFileMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        }),
        enum: t.field({
            type: DeprecatedFileEnum$Ref,
            required: false,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        })
    })
});
export type DeprecatedFileMessageInnerMessageInput$Shape = {
    body: _$testapis$deprecation$file_deprecation.DeprecatedFileMessage_InnerMessage[\\"body\\"];
};
export const DeprecatedFileMessageInnerMessageInput$Ref = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(\\"DeprecatedFileMessageInnerMessageInput\\");
DeprecatedFileMessageInnerMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true,
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\"
        })
    })
});
export const DeprecatedFileEnum$Ref = builder.enumType(\\"DeprecatedFileEnum\\", {
    values: {
        DEPRECATED_FILE_FOO: {
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\",
            value: 1
        },
        DEPRECATED_FILE_BAR: {
            deprecationReason: \\"testapis/deprecation/file_deprecation.proto is mark as deprecated.\\",
            value: 2
        }
    } as const
});
"
`;

exports[`empty types with ts-proto generates pothos DSLs: empty_types/empty.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$empty_types$empty from \\"./testapis/empty_types/empty\\";
export const EmptyMessage$Ref = builder.objectRef<_$testapis$empty_types$empty.EmptyMessage>(\\"EmptyMessage\\");
builder.objectType(EmptyMessage$Ref, {
    name: \\"EmptyMessage\\",
    fields: t => ({
        _: t.field({
            type: \\"Boolean\\",
            nullable: true,
            description: \\"noop field\\",
            resolve() { return true; }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$empty_types$empty.EmptyMessage | {
            $type: string & {};
        }).$type === \\"testapis.empty_types.EmptyMessage\\";
    }
});
export type EmptyMessageInput$Shape = {};
export const EmptyMessageInput$Ref = builder.inputRef<EmptyMessageInput$Shape>(\\"EmptyMessageInput\\");
EmptyMessageInput$Ref.implement({
    fields: t => ({
        _: t.field({
            type: \\"Boolean\\",
            required: false,
            description: \\"noop field\\"
        })
    })
});
"
`;

exports[`field_behavior with ts-proto generates pothos DSLs: field_behavior/comments.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$field_behavior$comments from \\"./testapis/field_behavior/comments\\";
export const FieldBehaviorComentsMessage$Ref = builder.objectRef<_$testapis$field_behavior$comments.FieldBehaviorComentsMessage>(\\"FieldBehaviorComentsMessage\\");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
    name: \\"FieldBehaviorComentsMessage\\",
    fields: t => ({
        requiredField: t.field({
            type: FieldBehaviorComentsMessagePost$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredField!;
            }
        }),
        requiredOutputOnlyField: t.field({
            type: FieldBehaviorComentsMessagePost$Ref,
            nullable: false,
            description: \\"Required. Output only.\\",
            resolve: source => {
                return source.requiredOutputOnlyField!;
            }
        }),
        outputOnlyRequiredField: t.field({
            type: FieldBehaviorComentsMessagePost$Ref,
            nullable: false,
            description: \\"Output only. Required.\\",
            resolve: source => {
                return source.outputOnlyRequiredField!;
            }
        }),
        outputOnlyField: t.expose(\\"outputOnlyField\\", {
            type: FieldBehaviorComentsMessagePost$Ref,
            nullable: true,
            description: \\"Output only.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$field_behavior$comments.FieldBehaviorComentsMessage | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.FieldBehaviorComentsMessage\\";
    }
});
export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<_$testapis$field_behavior$comments.FieldBehaviorComentsMessage_Post>(\\"FieldBehaviorComentsMessagePost\\");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
    name: \\"FieldBehaviorComentsMessagePost\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$field_behavior$comments.FieldBehaviorComentsMessage_Post | {
            $type: string & {};
        }).$type === \\"testapis.deprecation.FieldBehaviorComentsMessage.Post\\";
    }
});
export type FieldBehaviorComentsMessageInput$Shape = {
    requiredField: FieldBehaviorComentsMessagePostInput$Shape;
    requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
    inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
    inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};
export const FieldBehaviorComentsMessageInput$Ref = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(\\"FieldBehaviorComentsMessageInput\\");
FieldBehaviorComentsMessageInput$Ref.implement({
    fields: t => ({
        requiredField: t.field({
            type: FieldBehaviorComentsMessagePostInput$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        requiredInputOnlyField: t.field({
            type: FieldBehaviorComentsMessagePostInput$Ref,
            required: true,
            description: \\"Required. Input only.\\"
        }),
        inputOnlyRequiredField: t.field({
            type: FieldBehaviorComentsMessagePostInput$Ref,
            required: true,
            description: \\"Input only. Required.\\"
        }),
        inputOnlyField: t.field({
            type: FieldBehaviorComentsMessagePostInput$Ref,
            required: false,
            description: \\"Input only.\\"
        })
    })
});
export type FieldBehaviorComentsMessagePostInput$Shape = {
    body: _$testapis$field_behavior$comments.FieldBehaviorComentsMessage_Post[\\"body\\"];
};
export const FieldBehaviorComentsMessagePostInput$Ref = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(\\"FieldBehaviorComentsMessagePostInput\\");
FieldBehaviorComentsMessagePostInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`multipkgs with ts-proto generates pothos DSLs: multipkgs/subpkg1/types.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { builder } from \\"../../../builder\\";
import * as _$testapis$multipkgs$subpkg1$types from \\"./testapis/multipkgs/subpkg1/types\\";
export const SubpkgMessage$Ref = builder.objectRef<_$testapis$multipkgs$subpkg1$types.SubpkgMessage>(\\"SubpkgMessage\\");
builder.objectType(SubpkgMessage$Ref, {
    name: \\"SubpkgMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$multipkgs$subpkg1$types.SubpkgMessage | {
            $type: string & {};
        }).$type === \\"testapis.multipkgs.subpkg1.SubpkgMessage\\";
    }
});
export type SubpkgMessageInput$Shape = {
    body: _$testapis$multipkgs$subpkg1$types.SubpkgMessage[\\"body\\"];
};
export const SubpkgMessageInput$Ref = builder.inputRef<SubpkgMessageInput$Shape>(\\"SubpkgMessageInput\\");
SubpkgMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const SubpkgEnum$Ref = builder.enumType(\\"SubpkgEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            value: 2
        }
    } as const
});
"
`;

exports[`multipkgs with ts-proto generates pothos DSLs: multipkgs/subpkg2/types.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { builder } from \\"../../../builder\\";
import * as __$subpkg1$types_pb_pothos from \\"../subpkg1/types.pb.pothos\\";
import { SubpkgMessage$Ref } from \\"../subpkg1/types.pb.pothos\\";
import { SubpkgEnum$Ref } from \\"../subpkg1/types.pb.pothos\\";
import { SubpkgMessageInput$Ref } from \\"../subpkg1/types.pb.pothos\\";
import { SubpkgMessageInput$Shape } from \\"../subpkg1/types.pb.pothos\\";
import * as _$testapis$multipkgs$subpkg1$types from \\"./testapis/multipkgs/subpkg1/types\\";
import * as _$testapis$multipkgs$subpkg2$types from \\"./testapis/multipkgs/subpkg2/types\\";
export const MessageWithSubpkg$Ref = builder.objectRef<_$testapis$multipkgs$subpkg2$types.MessageWithSubpkg>(\\"MessageWithSubpkg\\");
builder.objectType(MessageWithSubpkg$Ref, {
    name: \\"MessageWithSubpkg\\",
    fields: t => ({
        message: t.expose(\\"message\\", {
            type: SubpkgMessage$Ref,
            nullable: true
        }),
        enum: t.field({
            type: SubpkgEnum$Ref,
            nullable: true,
            resolve: source => {
                if (source.enum === _$testapis$multipkgs$subpkg1$types.SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.enum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$multipkgs$subpkg2$types.MessageWithSubpkg | {
            $type: string & {};
        }).$type === \\"testapis.multipkgs.subpkg1.MessageWithSubpkg\\";
    }
});
export type MessageWithSubpkgInput$Shape = {
    message?: SubpkgMessageInput$Shape | null;
    enum?: _$testapis$multipkgs$subpkg2$types.MessageWithSubpkg[\\"enum\\"] | null;
};
export const MessageWithSubpkgInput$Ref = builder.inputRef<MessageWithSubpkgInput$Shape>(\\"MessageWithSubpkgInput\\");
MessageWithSubpkgInput$Ref.implement({
    fields: t => ({
        message: t.field({
            type: SubpkgMessageInput$Ref,
            required: false
        }),
        enum: t.field({
            type: SubpkgEnum$Ref,
            required: false
        })
    })
});
"
`;

exports[`nested protobuf types with ts-proto generates pothos DSLs: nested/nested.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$nested$nested from \\"./testapis/nested/nested\\";
export const ParentMessage$Ref = builder.objectRef<_$testapis$nested$nested.ParentMessage>(\\"ParentMessage\\");
builder.objectType(ParentMessage$Ref, {
    name: \\"ParentMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        }),
        nested: t.expose(\\"nested\\", {
            type: ParentMessageNestedMessage$Ref,
            nullable: true
        }),
        nestedEnum: t.field({
            type: ParentMessageNestedEnum$Ref,
            nullable: true,
            resolve: source => {
                if (source.nestedEnum === _$testapis$nested$nested.ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.nestedEnum;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$nested$nested.ParentMessage | {
            $type: string & {};
        }).$type === \\"testapis.nested.ParentMessage\\";
    }
});
export const ParentMessageNestedMessage$Ref = builder.objectRef<_$testapis$nested$nested.ParentMessage_NestedMessage>(\\"ParentMessageNestedMessage\\");
builder.objectType(ParentMessageNestedMessage$Ref, {
    name: \\"ParentMessageNestedMessage\\",
    fields: t => ({
        nestedBody: t.expose(\\"nestedBody\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$nested$nested.ParentMessage_NestedMessage | {
            $type: string & {};
        }).$type === \\"testapis.nested.ParentMessage.NestedMessage\\";
    }
});
export type ParentMessageInput$Shape = {
    body: _$testapis$nested$nested.ParentMessage[\\"body\\"];
    nested?: ParentMessageNestedMessageInput$Shape | null;
    nestedEnum?: _$testapis$nested$nested.ParentMessage[\\"nestedEnum\\"] | null;
};
export const ParentMessageInput$Ref = builder.inputRef<ParentMessageInput$Shape>(\\"ParentMessageInput\\");
ParentMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        }),
        nested: t.field({
            type: ParentMessageNestedMessageInput$Ref,
            required: false
        }),
        nestedEnum: t.field({
            type: ParentMessageNestedEnum$Ref,
            required: false
        })
    })
});
export type ParentMessageNestedMessageInput$Shape = {
    nestedBody: _$testapis$nested$nested.ParentMessage_NestedMessage[\\"nestedBody\\"];
};
export const ParentMessageNestedMessageInput$Ref = builder.inputRef<ParentMessageNestedMessageInput$Shape>(\\"ParentMessageNestedMessageInput\\");
ParentMessageNestedMessageInput$Ref.implement({
    fields: t => ({
        nestedBody: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const ParentMessageNestedEnum$Ref = builder.enumType(\\"ParentMessageNestedEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            value: 2
        }
    } as const
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixIgnoredMessageNotIgnored.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<_$testapis$extensions$extensions.IgnoredMessage_NotIgnored>(\\"TestPrefixIgnoredMessageNotIgnored\\");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
    name: \\"TestPrefixIgnoredMessageNotIgnored\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.IgnoredMessage_NotIgnored | {
            $type: string & {};
        }).$type === \\"testapis.extensions.IgnoredMessage.NotIgnored\\";
    }
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixIgnoredMessageNotIgnoredInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
    body: _$testapis$extensions$extensions.IgnoredMessage_NotIgnored[\\"body\\"];
};
export const TestPrefixIgnoredMessageNotIgnoredInput$Ref = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(\\"TestPrefixIgnoredMessageNotIgnoredInput\\");
TestPrefixIgnoredMessageNotIgnoredInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixInterfaceMessage.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<Pick<_$testapis$extensions$extensions.InterfaceMessage, \\"id\\">>(\\"TestPrefixInterfaceMessage\\");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
    name: \\"TestPrefixInterfaceMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixInterfaceMessageInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type TestPrefixInterfaceMessageInput$Shape = {
    id: _$testapis$extensions$extensions.InterfaceMessage[\\"id\\"];
};
export const TestPrefixInterfaceMessageInput$Ref = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(\\"TestPrefixInterfaceMessageInput\\");
TestPrefixInterfaceMessageInput$Ref.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixInterfaceMessageType.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export const TestPrefixInterfaceMessageType$Ref = builder.enumType(\\"TestPrefixInterfaceMessageType\\", {
    values: {
        INNER: {
            value: 1
        },
        INNER2: {
            value: 2
        }
    } as const
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedEnum.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export const TestPrefixPrefixedEnum$Ref = builder.enumType(\\"TestPrefixPrefixedEnum\\", {
    values: {
        PREFIXED_FOO: {
            value: 1
        },
        PREFIXED_BAR: {
            value: 2
        }
    } as const
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessage.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$TestPrefixIgnoredMessageNotIgnored_pothos from \\"./TestPrefixIgnoredMessageNotIgnored.pothos\\";
import * as _$TestPrefixPrefixedEnum_pothos from \\"./TestPrefixPrefixedEnum.pothos\\";
import * as _$TestPrefixPrefixedMessagePartialIgnoreOneof_pothos from \\"./TestPrefixPrefixedMessagePartialIgnoreOneof.pothos\\";
import * as _$TestPrefixPrefixedMessageSquashedMessage_pothos from \\"./TestPrefixPrefixedMessageSquashedMessage.pothos\\";
import * as _$TestPrefixRenamedMessage_pothos from \\"./TestPrefixRenamedMessage.pothos\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessage$Ref = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage>(\\"TestPrefixPrefixedMessage\\");
builder.objectType(TestPrefixPrefixedMessage$Ref, {
    name: \\"TestPrefixPrefixedMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false,
            description: \\"Output only.\\"
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum$Ref,
            nullable: true,
            resolve: source => {
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
                    return null;
                }
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_IGNORED) {
                    throw new Error(\\"PREFIXED_IGNORED is ignored in GraphQL schema\\");
                }
                return source.prefixedEnum;
            }
        }),
        notIgnoredMessage: t.expose(\\"notIgnoredMessage\\", {
            type: TestPrefixIgnoredMessageNotIgnored$Ref,
            nullable: true
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessage$Ref,
            nullable: true,
            resolve: source => {
                const value = source.squashedMessage?.oneofField ?? source.squashedMessage?.oneofField2;
                return value;
            }
        }),
        thisFieldWasRenamed: t.expose(\\"thisFieldWillBeRenamed\\", {
            type: \\"String\\",
            nullable: false
        }),
        skipResolver: t.expose(\\"skipResolver\\", {
            type: \\"String\\",
            nullable: false
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
            nullable: { list: true, items: false },
            resolve: source => {
                return source.squashedMessages.map(item => {
                    const value = item?.oneofField ?? item?.oneofField2;
                    if (value == null) {
                        throw new Error(\\"squashedMessages should not be null\\");
                    }
                    return value;
                });
            }
        }),
        renamedMessage: t.expose(\\"renamedMessage\\", {
            type: TestPrefixRenamedMessage$Ref,
            nullable: true
        }),
        partialIgnoreOneof: t.field({
            type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
            nullable: true,
            resolve: source => {
                const value = source.oneofNotIgnoredField;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage\\";
    }
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessage.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage>(\\"TestPrefixPrefixedMessageInnerMessage\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
    name: \\"TestPrefixPrefixedMessageInnerMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage\\";
    }
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessage2.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage2>(\\"TestPrefixPrefixedMessageInnerMessage2\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
    name: \\"TestPrefixPrefixedMessageInnerMessage2\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage2\\";
    }
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessage2Input.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessage2Input$Ref = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(\\"TestPrefixPrefixedMessageInnerMessage2Input\\");
TestPrefixPrefixedMessageInnerMessage2Input$Ref.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInnerMessageInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessageInput$Ref = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(\\"TestPrefixPrefixedMessageInnerMessageInput\\");
TestPrefixPrefixedMessageInnerMessageInput$Ref.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$TestPrefixIgnoredMessageNotIgnoredInput_pothos from \\"./TestPrefixIgnoredMessageNotIgnoredInput.pothos\\";
import * as _$TestPrefixPrefixedEnum_pothos from \\"./TestPrefixPrefixedEnum.pothos\\";
import * as _$TestPrefixPrefixedMessageInnerMessageInput_pothos from \\"./TestPrefixPrefixedMessageInnerMessageInput.pothos\\";
import * as _$TestPrefixPrefixedMessageSquashedMessageInput_pothos from \\"./TestPrefixPrefixedMessageSquashedMessageInput.pothos\\";
import * as _$TestPrefixRenamedMessageInput_pothos from \\"./TestPrefixRenamedMessageInput.pothos\\";
export type TestPrefixPrefixedMessageInput$Shape = {
    body: _$testapis$extensions$extensions.PrefixedMessage[\\"body\\"];
    prefixedEnum?: _$testapis$extensions$extensions.PrefixedMessage[\\"prefixedEnum\\"] | null;
    notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
    squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
    thisFieldWasRenamed: _$testapis$extensions$extensions.PrefixedMessage[\\"thisFieldWillBeRenamed\\"];
    oneofNotIgnoredField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
    skipResolver: _$testapis$extensions$extensions.PrefixedMessage[\\"skipResolver\\"];
    squashedMessages?: Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape> | null;
    renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
};
export const TestPrefixPrefixedMessageInput$Ref = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(\\"TestPrefixPrefixedMessageInput\\");
TestPrefixPrefixedMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum$Ref,
            required: false
        }),
        notIgnoredMessage: t.field({
            type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
            required: false
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
            required: false
        }),
        thisFieldWasRenamed: t.field({
            type: \\"String\\",
            required: true
        }),
        oneofNotIgnoredField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
            required: false
        }),
        skipResolver: t.field({
            type: \\"String\\",
            required: true
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
            required: { list: false, items: true }
        }),
        renamedMessage: t.field({
            type: TestPrefixRenamedMessageInput$Ref,
            required: false
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessagePartialIgnoreOneof.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$TestPrefixPrefixedMessageInnerMessage_pothos from \\"./TestPrefixPrefixedMessageInnerMessage.pothos\\";
export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder.unionType(\\"TestPrefixPrefixedMessagePartialIgnoreOneof\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage$Ref
    ]
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageSquashedMessage.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$TestPrefixPrefixedMessageInnerMessage_pothos from \\"./TestPrefixPrefixedMessageInnerMessage.pothos\\";
import * as _$TestPrefixPrefixedMessageInnerMessage2_pothos from \\"./TestPrefixPrefixedMessageInnerMessage2.pothos\\";
export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(\\"TestPrefixPrefixedMessageSquashedMessage\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage$Ref,
        TestPrefixPrefixedMessageInnerMessage2$Ref
    ]
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixPrefixedMessageSquashedMessageInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$TestPrefixPrefixedMessageInnerMessage2Input_pothos from \\"./TestPrefixPrefixedMessageInnerMessage2Input.pothos\\";
import * as _$TestPrefixPrefixedMessageInnerMessageInput_pothos from \\"./TestPrefixPrefixedMessageInnerMessageInput.pothos\\";
export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
    oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
    oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};
export const TestPrefixPrefixedMessageSquashedMessageInput$Ref = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(\\"TestPrefixPrefixedMessageSquashedMessageInput\\");
TestPrefixPrefixedMessageSquashedMessageInput$Ref.implement({
    fields: t => ({
        oneofField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
            required: false
        }),
        oneofField2: t.field({
            type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
            required: false
        })
    })
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixRenamedMessage.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixRenamedMessage$Ref = builder.objectRef<_$testapis$extensions$extensions.MessageWillRename>(\\"TestPrefixRenamedMessage\\");
builder.objectType(TestPrefixRenamedMessage$Ref, {
    name: \\"TestPrefixRenamedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.MessageWillRename | {
            $type: string & {};
        }).$type === \\"testapis.extensions.MessageWillRename\\";
    }
});
"
`;

exports[`protobuf custom options generates pothos DSLs with graphql_type file layout: extensions/TestPrefixRenamedMessageInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type TestPrefixRenamedMessageInput$Shape = {
    body: _$testapis$extensions$extensions.MessageWillRename[\\"body\\"];
};
export const TestPrefixRenamedMessageInput$Ref = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(\\"TestPrefixRenamedMessageInput\\");
TestPrefixRenamedMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf custom options with ts-proto generates pothos DSLs: extensions/extensions.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$extensions$extensions from \\"./testapis/extensions/extensions\\";
export const TestPrefixPrefixedMessage$Ref = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage>(\\"TestPrefixPrefixedMessage\\");
builder.objectType(TestPrefixPrefixedMessage$Ref, {
    name: \\"TestPrefixPrefixedMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false,
            description: \\"Output only.\\"
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum$Ref,
            nullable: true,
            resolve: source => {
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
                    return null;
                }
                if (source.prefixedEnum === _$testapis$extensions$extensions.PrefixedEnum.PREFIXED_IGNORED) {
                    throw new Error(\\"PREFIXED_IGNORED is ignored in GraphQL schema\\");
                }
                return source.prefixedEnum;
            }
        }),
        notIgnoredMessage: t.expose(\\"notIgnoredMessage\\", {
            type: TestPrefixIgnoredMessageNotIgnored$Ref,
            nullable: true
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessage$Ref,
            nullable: true,
            resolve: source => {
                const value = source.squashedMessage?.oneofField ?? source.squashedMessage?.oneofField2;
                return value;
            }
        }),
        thisFieldWasRenamed: t.expose(\\"thisFieldWillBeRenamed\\", {
            type: \\"String\\",
            nullable: false
        }),
        skipResolver: t.expose(\\"skipResolver\\", {
            type: \\"String\\",
            nullable: false
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
            nullable: { list: true, items: false },
            resolve: source => {
                return source.squashedMessages.map(item => {
                    const value = item?.oneofField ?? item?.oneofField2;
                    if (value == null) {
                        throw new Error(\\"squashedMessages should not be null\\");
                    }
                    return value;
                });
            }
        }),
        renamedMessage: t.expose(\\"renamedMessage\\", {
            type: TestPrefixRenamedMessage$Ref,
            nullable: true
        }),
        partialIgnoreOneof: t.field({
            type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
            nullable: true,
            resolve: source => {
                const value = source.oneofNotIgnoredField;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage\\";
    }
});
export const TestPrefixRenamedMessage$Ref = builder.objectRef<_$testapis$extensions$extensions.MessageWillRename>(\\"TestPrefixRenamedMessage\\");
builder.objectType(TestPrefixRenamedMessage$Ref, {
    name: \\"TestPrefixRenamedMessage\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.MessageWillRename | {
            $type: string & {};
        }).$type === \\"testapis.extensions.MessageWillRename\\";
    }
});
export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage>(\\"TestPrefixPrefixedMessageInnerMessage\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
    name: \\"TestPrefixPrefixedMessageInnerMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage\\";
    }
});
export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<_$testapis$extensions$extensions.PrefixedMessage_InnerMessage2>(\\"TestPrefixPrefixedMessageInnerMessage2\\");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
    name: \\"TestPrefixPrefixedMessageInnerMessage2\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        }),
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.extensions.PrefixedMessage.InnerMessage2\\";
    }
});
export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<_$testapis$extensions$extensions.IgnoredMessage_NotIgnored>(\\"TestPrefixIgnoredMessageNotIgnored\\");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
    name: \\"TestPrefixIgnoredMessageNotIgnored\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$extensions$extensions.IgnoredMessage_NotIgnored | {
            $type: string & {};
        }).$type === \\"testapis.extensions.IgnoredMessage.NotIgnored\\";
    }
});
export type TestPrefixPrefixedMessageInput$Shape = {
    body: _$testapis$extensions$extensions.PrefixedMessage[\\"body\\"];
    prefixedEnum?: _$testapis$extensions$extensions.PrefixedMessage[\\"prefixedEnum\\"] | null;
    notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
    squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
    thisFieldWasRenamed: _$testapis$extensions$extensions.PrefixedMessage[\\"thisFieldWillBeRenamed\\"];
    oneofNotIgnoredField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
    skipResolver: _$testapis$extensions$extensions.PrefixedMessage[\\"skipResolver\\"];
    squashedMessages?: Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape> | null;
    renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
};
export const TestPrefixPrefixedMessageInput$Ref = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(\\"TestPrefixPrefixedMessageInput\\");
TestPrefixPrefixedMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        }),
        prefixedEnum: t.field({
            type: TestPrefixPrefixedEnum$Ref,
            required: false
        }),
        notIgnoredMessage: t.field({
            type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
            required: false
        }),
        squashedMessage: t.field({
            type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
            required: false
        }),
        thisFieldWasRenamed: t.field({
            type: \\"String\\",
            required: true
        }),
        oneofNotIgnoredField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
            required: false
        }),
        skipResolver: t.field({
            type: \\"String\\",
            required: true
        }),
        squashedMessages: t.field({
            type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
            required: { list: false, items: true }
        }),
        renamedMessage: t.field({
            type: TestPrefixRenamedMessageInput$Ref,
            required: false
        })
    })
});
export type TestPrefixRenamedMessageInput$Shape = {
    body: _$testapis$extensions$extensions.MessageWillRename[\\"body\\"];
};
export const TestPrefixRenamedMessageInput$Ref = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(\\"TestPrefixRenamedMessageInput\\");
TestPrefixRenamedMessageInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixInterfaceMessageInput$Shape = {
    id: _$testapis$extensions$extensions.InterfaceMessage[\\"id\\"];
};
export const TestPrefixInterfaceMessageInput$Ref = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(\\"TestPrefixInterfaceMessageInput\\");
TestPrefixInterfaceMessageInput$Ref.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessageInput$Ref = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(\\"TestPrefixPrefixedMessageInnerMessageInput\\");
TestPrefixPrefixedMessageInnerMessageInput$Ref.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
    id: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"id\\"];
    body: _$testapis$extensions$extensions.PrefixedMessage_InnerMessage2[\\"body\\"];
};
export const TestPrefixPrefixedMessageInnerMessage2Input$Ref = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(\\"TestPrefixPrefixedMessageInnerMessage2Input\\");
TestPrefixPrefixedMessageInnerMessage2Input$Ref.implement({
    fields: t => ({
        id: t.field({
            type: \\"String\\",
            required: true
        }),
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
    oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
    oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};
export const TestPrefixPrefixedMessageSquashedMessageInput$Ref = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(\\"TestPrefixPrefixedMessageSquashedMessageInput\\");
TestPrefixPrefixedMessageSquashedMessageInput$Ref.implement({
    fields: t => ({
        oneofField: t.field({
            type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
            required: false
        }),
        oneofField2: t.field({
            type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
            required: false
        })
    })
});
export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
    body: _$testapis$extensions$extensions.IgnoredMessage_NotIgnored[\\"body\\"];
};
export const TestPrefixIgnoredMessageNotIgnoredInput$Ref = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(\\"TestPrefixIgnoredMessageNotIgnoredInput\\");
TestPrefixIgnoredMessageNotIgnoredInput$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<Pick<_$testapis$extensions$extensions.InterfaceMessage, \\"id\\">>(\\"TestPrefixInterfaceMessage\\");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
    name: \\"TestPrefixInterfaceMessage\\",
    fields: t => ({
        id: t.expose(\\"id\\", {
            type: \\"String\\",
            nullable: false
        })
    })
});
export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(\\"TestPrefixPrefixedMessageSquashedMessage\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage$Ref,
        TestPrefixPrefixedMessageInnerMessage2$Ref
    ]
});
export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder.unionType(\\"TestPrefixPrefixedMessagePartialIgnoreOneof\\", {
    types: [
        TestPrefixPrefixedMessageInnerMessage$Ref
    ]
});
export const TestPrefixPrefixedEnum$Ref = builder.enumType(\\"TestPrefixPrefixedEnum\\", {
    values: {
        PREFIXED_FOO: {
            value: 1
        },
        PREFIXED_BAR: {
            value: 2
        }
    } as const
});
export const TestPrefixInterfaceMessageType$Ref = builder.enumType(\\"TestPrefixInterfaceMessageType\\", {
    values: {
        INNER: {
            value: 1
        },
        INNER2: {
            value: 2
        }
    } as const
});
"
`;

exports[`protobuf custom options with ts-proto generates pothos DSLs: extensions/ignored.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MessageWithEnums.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$MyEnum_pothos from \\"./MyEnum.pothos\\";
import * as _$MyEnumWithoutUnspecified_pothos from \\"./MyEnumWithoutUnspecified.pothos\\";
import * as _$testapis$enums$enums from \\"./testapis/enums/enums\\";
export const MessageWithEnums$Ref = builder.objectRef<_$testapis$enums$enums.MessageWithEnums>(\\"MessageWithEnums\\");
builder.objectType(MessageWithEnums$Ref, {
    name: \\"MessageWithEnums\\",
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                if (source.requiredMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    throw new Error(\\"requiredMyEnum is required field. But got unspecified.\\");
                }
                return source.requiredMyEnum;
            }
        }),
        optionalMyEnum: t.field({
            type: MyEnum$Ref,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                if (source.optionalMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.optionalMyEnum;
            }
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecified;
            }
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecified;
            }
        }),
        requiredMyEnums: t.field({
            type: [MyEnum$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"requiredMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        optionalMyEnums: t.field({
            type: [MyEnum$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"optionalMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecifieds;
            }
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecifieds;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$enums$enums.MessageWithEnums | {
            $type: string & {};
        }).$type === \\"testapi.enums.MessageWithEnums\\";
    }
});
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MessageWithEnumsInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$MyEnum_pothos from \\"./MyEnum.pothos\\";
import * as _$MyEnumWithoutUnspecified_pothos from \\"./MyEnumWithoutUnspecified.pothos\\";
export type MessageWithEnumsInput$Shape = {
    requiredMyEnum: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnum\\"];
    optionalMyEnum?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnum\\"] | null;
    requiredMyEnumWithoutUnspecified: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecified\\"];
    optionalMyEnumWithoutUnspecified?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecified\\"] | null;
    requiredMyEnums: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnums\\"];
    optionalMyEnums?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnums\\"] | null;
    requiredMyEnumWithoutUnspecifieds: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecifieds\\"];
    optionalMyEnumWithoutUnspecifieds?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecifieds\\"] | null;
};
export const MessageWithEnumsInput$Ref = builder.inputRef<MessageWithEnumsInput$Shape>(\\"MessageWithEnumsInput\\");
MessageWithEnumsInput$Ref.implement({
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnum: t.field({
            type: MyEnum$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnums: t.field({
            type: [MyEnum$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnums: t.field({
            type: [MyEnum$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MyEnum.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export const MyEnum$Ref = builder.enumType(\\"MyEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            description: \\"This is Bar.\\",
            value: 2
        },
        BAZ: {
            value: 3
        }
    } as const
});
"
`;

exports[`protobuf enums generates pothos DSLs with graphql_type file layout: enums/MyEnumWithoutUnspecified.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export const MyEnumWithoutUnspecified$Ref = builder.enumType(\\"MyEnumWithoutUnspecified\\", {
    values: {
        FOO: {
            value: 0
        },
        BAR: {
            value: 1
        },
        BAZ: {
            value: 2
        }
    } as const
});
"
`;

exports[`protobuf enums with ts-proto generates pothos DSLs: enums/enums.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$enums$enums from \\"./testapis/enums/enums\\";
export const MessageWithEnums$Ref = builder.objectRef<_$testapis$enums$enums.MessageWithEnums>(\\"MessageWithEnums\\");
builder.objectType(MessageWithEnums$Ref, {
    name: \\"MessageWithEnums\\",
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                if (source.requiredMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    throw new Error(\\"requiredMyEnum is required field. But got unspecified.\\");
                }
                return source.requiredMyEnum;
            }
        }),
        optionalMyEnum: t.field({
            type: MyEnum$Ref,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                if (source.optionalMyEnum === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                    return null;
                }
                return source.optionalMyEnum;
            }
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecified;
            }
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            nullable: true,
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecified;
            }
        }),
        requiredMyEnums: t.field({
            type: [MyEnum$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"requiredMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        optionalMyEnums: t.field({
            type: [MyEnum$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnums.map(item => {
                    if (item === _$testapis$enums$enums.MyEnum.MY_ENUM_UNSPECIFIED) {
                        throw new Error(\\"optionalMyEnums is required field. But got unspecified.\\");
                    }
                    return item;
                });
            }
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredMyEnumWithoutUnspecifieds;
            }
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\",
            resolve: source => {
                return source.optionalMyEnumWithoutUnspecifieds;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$enums$enums.MessageWithEnums | {
            $type: string & {};
        }).$type === \\"testapi.enums.MessageWithEnums\\";
    }
});
export type MessageWithEnumsInput$Shape = {
    requiredMyEnum: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnum\\"];
    optionalMyEnum?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnum\\"] | null;
    requiredMyEnumWithoutUnspecified: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecified\\"];
    optionalMyEnumWithoutUnspecified?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecified\\"] | null;
    requiredMyEnums: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnums\\"];
    optionalMyEnums?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnums\\"] | null;
    requiredMyEnumWithoutUnspecifieds: _$testapis$enums$enums.MessageWithEnums[\\"requiredMyEnumWithoutUnspecifieds\\"];
    optionalMyEnumWithoutUnspecifieds?: _$testapis$enums$enums.MessageWithEnums[\\"optionalMyEnumWithoutUnspecifieds\\"] | null;
};
export const MessageWithEnumsInput$Ref = builder.inputRef<MessageWithEnumsInput$Shape>(\\"MessageWithEnumsInput\\");
MessageWithEnumsInput$Ref.implement({
    fields: t => ({
        requiredMyEnum: t.field({
            type: MyEnum$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnum: t.field({
            type: MyEnum$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecified: t.field({
            type: MyEnumWithoutUnspecified$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredMyEnums: t.field({
            type: [MyEnum$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnums: t.field({
            type: [MyEnum$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
            type: [MyEnumWithoutUnspecified$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export const MyEnum$Ref = builder.enumType(\\"MyEnum\\", {
    values: {
        FOO: {
            value: 1
        },
        BAR: {
            description: \\"This is Bar.\\",
            value: 2
        },
        BAZ: {
            value: 3
        }
    } as const
});
export const MyEnumWithoutUnspecified$Ref = builder.enumType(\\"MyEnumWithoutUnspecified\\", {
    values: {
        FOO: {
            value: 0
        },
        BAR: {
            value: 1
        },
        BAZ: {
            value: 2
        }
    } as const
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage1.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofMemberMessage1$Ref = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage1>(\\"OneofMemberMessage1\\");
builder.objectType(OneofMemberMessage1$Ref, {
    name: \\"OneofMemberMessage1\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage1 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage1\\";
    }
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage1Input.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type OneofMemberMessage1Input$Shape = {
    body: _$testapis$oneof$oneof.OneofMemberMessage1[\\"body\\"];
};
export const OneofMemberMessage1Input$Ref = builder.inputRef<OneofMemberMessage1Input$Shape>(\\"OneofMemberMessage1Input\\");
OneofMemberMessage1Input$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage2.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofMemberMessage2$Ref = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage2>(\\"OneofMemberMessage2\\");
builder.objectType(OneofMemberMessage2$Ref, {
    name: \\"OneofMemberMessage2\\",
    fields: t => ({
        imageUrl: t.expose(\\"imageUrl\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage2\\";
    }
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofMemberMessage2Input.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type OneofMemberMessage2Input$Shape = {
    imageUrl: _$testapis$oneof$oneof.OneofMemberMessage2[\\"imageUrl\\"];
};
export const OneofMemberMessage2Input$Ref = builder.inputRef<OneofMemberMessage2Input$Shape>(\\"OneofMemberMessage2Input\\");
OneofMemberMessage2Input$Ref.implement({
    fields: t => ({
        imageUrl: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParent.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$OneofParentOptionalOneofMembers_pothos from \\"./OneofParentOptionalOneofMembers.pothos\\";
import * as _$OneofParentRequiredOneofMembers_pothos from \\"./OneofParentRequiredOneofMembers.pothos\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofParent$Ref = builder.objectRef<_$testapis$oneof$oneof.OneofParent>(\\"OneofParent\\");
builder.objectType(OneofParent$Ref, {
    name: \\"OneofParent\\",
    fields: t => ({
        normalField: t.expose(\\"normalField\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredOneofMembers: t.field({
            type: OneofParentRequiredOneofMembers$Ref,
            nullable: false,
            description: \\"Required. disallow not_set.\\",
            resolve: source => {
                const value = source.requiredMessage1 ?? source.requiredMessage2;
                if (value == null) {
                    throw new Error(\\"requiredOneofMembers should not be null\\");
                }
                return value;
            }
        }),
        optionalOneofMembers: t.field({
            type: OneofParentOptionalOneofMembers$Ref,
            nullable: true,
            resolve: source => {
                const value = source.optoinalMessage1 ?? source.optoinalMessage2;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofParent | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofParent\\";
    }
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParentInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$OneofMemberMessage1Input_pothos from \\"./OneofMemberMessage1Input.pothos\\";
import * as _$OneofMemberMessage2Input_pothos from \\"./OneofMemberMessage2Input.pothos\\";
export type OneofParentInput$Shape = {
    normalField: _$testapis$oneof$oneof.OneofParent[\\"normalField\\"];
    requiredMessage1?: OneofMemberMessage1Input$Shape | null;
    requiredMessage2?: OneofMemberMessage2Input$Shape | null;
    optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
    optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};
export const OneofParentInput$Ref = builder.inputRef<OneofParentInput$Shape>(\\"OneofParentInput\\");
OneofParentInput$Ref.implement({
    fields: t => ({
        normalField: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredMessage1: t.field({
            type: OneofMemberMessage1Input$Ref,
            required: false
        }),
        requiredMessage2: t.field({
            type: OneofMemberMessage2Input$Ref,
            required: false
        }),
        optoinalMessage1: t.field({
            type: OneofMemberMessage1Input$Ref,
            required: false
        }),
        optoinalMessage2: t.field({
            type: OneofMemberMessage2Input$Ref,
            required: false
        })
    })
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParentOptionalOneofMembers.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$OneofMemberMessage1_pothos from \\"./OneofMemberMessage1.pothos\\";
import * as _$OneofMemberMessage2_pothos from \\"./OneofMemberMessage2.pothos\\";
export const OneofParentOptionalOneofMembers$Ref = builder.unionType(\\"OneofParentOptionalOneofMembers\\", {
    types: [
        OneofMemberMessage1$Ref,
        OneofMemberMessage2$Ref
    ]
});
"
`;

exports[`protobuf oneof generates pothos DSLs with graphql_type file layout: oneof/OneofParentRequiredOneofMembers.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$OneofMemberMessage1_pothos from \\"./OneofMemberMessage1.pothos\\";
import * as _$OneofMemberMessage2_pothos from \\"./OneofMemberMessage2.pothos\\";
export const OneofParentRequiredOneofMembers$Ref = builder.unionType(\\"OneofParentRequiredOneofMembers\\", {
    description: \\"Required. disallow not_set.\\",
    types: [
        OneofMemberMessage1$Ref,
        OneofMemberMessage2$Ref
    ]
});
"
`;

exports[`protobuf oneof with ts-proto generates pothos DSLs: oneof/oneof.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$oneof$oneof from \\"./testapis/oneof/oneof\\";
export const OneofParent$Ref = builder.objectRef<_$testapis$oneof$oneof.OneofParent>(\\"OneofParent\\");
builder.objectType(OneofParent$Ref, {
    name: \\"OneofParent\\",
    fields: t => ({
        normalField: t.expose(\\"normalField\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredOneofMembers: t.field({
            type: OneofParentRequiredOneofMembers$Ref,
            nullable: false,
            description: \\"Required. disallow not_set.\\",
            resolve: source => {
                const value = source.requiredMessage1 ?? source.requiredMessage2;
                if (value == null) {
                    throw new Error(\\"requiredOneofMembers should not be null\\");
                }
                return value;
            }
        }),
        optionalOneofMembers: t.field({
            type: OneofParentOptionalOneofMembers$Ref,
            nullable: true,
            resolve: source => {
                const value = source.optoinalMessage1 ?? source.optoinalMessage2;
                return value;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofParent | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofParent\\";
    }
});
export const OneofMemberMessage1$Ref = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage1>(\\"OneofMemberMessage1\\");
builder.objectType(OneofMemberMessage1$Ref, {
    name: \\"OneofMemberMessage1\\",
    fields: t => ({
        body: t.expose(\\"body\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage1 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage1\\";
    }
});
export const OneofMemberMessage2$Ref = builder.objectRef<_$testapis$oneof$oneof.OneofMemberMessage2>(\\"OneofMemberMessage2\\");
builder.objectType(OneofMemberMessage2$Ref, {
    name: \\"OneofMemberMessage2\\",
    fields: t => ({
        imageUrl: t.expose(\\"imageUrl\\", {
            type: \\"String\\",
            nullable: false
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$oneof$oneof.OneofMemberMessage2 | {
            $type: string & {};
        }).$type === \\"testapis.oneof.OneofMemberMessage2\\";
    }
});
export type OneofParentInput$Shape = {
    normalField: _$testapis$oneof$oneof.OneofParent[\\"normalField\\"];
    requiredMessage1?: OneofMemberMessage1Input$Shape | null;
    requiredMessage2?: OneofMemberMessage2Input$Shape | null;
    optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
    optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};
export const OneofParentInput$Ref = builder.inputRef<OneofParentInput$Shape>(\\"OneofParentInput\\");
OneofParentInput$Ref.implement({
    fields: t => ({
        normalField: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredMessage1: t.field({
            type: OneofMemberMessage1Input$Ref,
            required: false
        }),
        requiredMessage2: t.field({
            type: OneofMemberMessage2Input$Ref,
            required: false
        }),
        optoinalMessage1: t.field({
            type: OneofMemberMessage1Input$Ref,
            required: false
        }),
        optoinalMessage2: t.field({
            type: OneofMemberMessage2Input$Ref,
            required: false
        })
    })
});
export type OneofMemberMessage1Input$Shape = {
    body: _$testapis$oneof$oneof.OneofMemberMessage1[\\"body\\"];
};
export const OneofMemberMessage1Input$Ref = builder.inputRef<OneofMemberMessage1Input$Shape>(\\"OneofMemberMessage1Input\\");
OneofMemberMessage1Input$Ref.implement({
    fields: t => ({
        body: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export type OneofMemberMessage2Input$Shape = {
    imageUrl: _$testapis$oneof$oneof.OneofMemberMessage2[\\"imageUrl\\"];
};
export const OneofMemberMessage2Input$Ref = builder.inputRef<OneofMemberMessage2Input$Shape>(\\"OneofMemberMessage2Input\\");
OneofMemberMessage2Input$Ref.implement({
    fields: t => ({
        imageUrl: t.field({
            type: \\"String\\",
            required: true
        })
    })
});
export const OneofParentRequiredOneofMembers$Ref = builder.unionType(\\"OneofParentRequiredOneofMembers\\", {
    description: \\"Required. disallow not_set.\\",
    types: [
        OneofMemberMessage1$Ref,
        OneofMemberMessage2$Ref
    ]
});
export const OneofParentOptionalOneofMembers$Ref = builder.unionType(\\"OneofParentOptionalOneofMembers\\", {
    types: [
        OneofMemberMessage1$Ref,
        OneofMemberMessage2$Ref
    ]
});
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/Message.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$Primitives_pothos from \\"./Primitives.pothos\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Message$Ref = builder.objectRef<_$testapis$primitives$primitives.Message>(\\"Message\\");
builder.objectType(Message$Ref, {
    name: \\"Message\\",
    fields: t => ({
        requiredPrimitives: t.field({
            type: Primitives$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitives!;
            }
        }),
        optionalPrimitives: t.expose(\\"optionalPrimitives\\", {
            type: Primitives$Ref,
            nullable: true,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [Primitives$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitivesList!;
            }
        }),
        optionalPrimitivesList: t.expose(\\"optionalPrimitivesList\\", {
            type: [Primitives$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Message | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Message\\";
    }
});
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/MessageInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$PrimitivesInput_pothos from \\"./PrimitivesInput.pothos\\";
export type MessageInput$Shape = {
    requiredPrimitives: PrimitivesInput$Shape;
    optionalPrimitives?: PrimitivesInput$Shape | null;
    requiredPrimitivesList: Array<PrimitivesInput$Shape>;
    optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};
export const MessageInput$Ref = builder.inputRef<MessageInput$Shape>(\\"MessageInput\\");
MessageInput$Ref.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesInput$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesInput$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesInput$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesInput$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/Primitives.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Primitives$Ref = builder.objectRef<_$testapis$primitives$primitives.Primitives>(\\"Primitives\\");
builder.objectType(Primitives$Ref, {
    name: \\"Primitives\\",
    fields: t => ({
        requiredDoubleValue: t.expose(\\"requiredDoubleValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredFloatValue: t.expose(\\"requiredFloatValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredInt32Value: t.expose(\\"requiredInt32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredInt64Value: t.expose(\\"requiredInt64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredUint32Value: t.expose(\\"requiredUint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredUint64Value: t.expose(\\"requiredUint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSint32Value: t.expose(\\"requiredSint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSint64Value: t.expose(\\"requiredSint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredFixed32Value: t.expose(\\"requiredFixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredFixed64Value: t.expose(\\"requiredFixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSfixed32Value: t.expose(\\"requiredSfixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSfixed64Value: t.expose(\\"requiredSfixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredBoolValue: t.expose(\\"requiredBoolValue\\", {
            type: \\"Boolean\\",
            nullable: false
        }),
        requiredStringValue: t.expose(\\"requiredStringValue\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredDoubleValues: t.expose(\\"requiredDoubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredFloatValues: t.expose(\\"requiredFloatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt32Values: t.expose(\\"requiredInt32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt64Values: t.expose(\\"requiredInt64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint32Values: t.expose(\\"requiredUint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint64Values: t.expose(\\"requiredUint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint32Values: t.expose(\\"requiredSint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint64Values: t.expose(\\"requiredSint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed32Values: t.expose(\\"requiredFixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed64Values: t.expose(\\"requiredFixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed32Values: t.expose(\\"requiredSfixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed64Values: t.expose(\\"requiredSfixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredBoolValues: t.expose(\\"requiredBoolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: false, items: false }
        }),
        requiredStringValues: t.expose(\\"requiredStringValues\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Primitives | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Primitives\\";
    }
});
"
`;

exports[`simple proto file generates pothos DSLs with graphql_type file layout: primitives/PrimitivesInput.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
export type PrimitivesInput$Shape = {
    requiredDoubleValue: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"];
    requiredFloatValue: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"];
    requiredInt32Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"];
    requiredInt64Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"];
    requiredUint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"];
    requiredUint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"];
    requiredSint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"];
    requiredSint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"];
    requiredFixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"];
    requiredFixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"];
    requiredSfixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"];
    requiredSfixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"];
    requiredBoolValue: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"];
    requiredStringValue: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"];
    requiredDoubleValues: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"];
    requiredFloatValues: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"];
    requiredInt32Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"];
    requiredInt64Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"];
    requiredUint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"];
    requiredUint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"];
    requiredSint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"];
    requiredSint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"];
    requiredFixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"];
    requiredFixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"];
    requiredSfixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"];
    requiredSfixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"];
    requiredBoolValues: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"];
    requiredStringValues: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"];
};
export const PrimitivesInput$Ref = builder.inputRef<PrimitivesInput$Shape>(\\"PrimitivesInput\\");
PrimitivesInput$Ref.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: true
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: true, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        })
    })
});
"
`;

exports[`simple proto file generates pothos DSLs with partial inputs: primitives/primitives.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Message$Ref = builder.objectRef<_$testapis$primitives$primitives.Message>(\\"Message\\");
builder.objectType(Message$Ref, {
    name: \\"Message\\",
    fields: t => ({
        requiredPrimitives: t.field({
            type: Primitives$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitives!;
            }
        }),
        optionalPrimitives: t.expose(\\"optionalPrimitives\\", {
            type: Primitives$Ref,
            nullable: true,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [Primitives$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitivesList!;
            }
        }),
        optionalPrimitivesList: t.expose(\\"optionalPrimitivesList\\", {
            type: [Primitives$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Message | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Message\\";
    }
});
export const Primitives$Ref = builder.objectRef<_$testapis$primitives$primitives.Primitives>(\\"Primitives\\");
builder.objectType(Primitives$Ref, {
    name: \\"Primitives\\",
    fields: t => ({
        requiredDoubleValue: t.expose(\\"requiredDoubleValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredFloatValue: t.expose(\\"requiredFloatValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredInt32Value: t.expose(\\"requiredInt32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredInt64Value: t.expose(\\"requiredInt64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredUint32Value: t.expose(\\"requiredUint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredUint64Value: t.expose(\\"requiredUint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSint32Value: t.expose(\\"requiredSint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSint64Value: t.expose(\\"requiredSint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredFixed32Value: t.expose(\\"requiredFixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredFixed64Value: t.expose(\\"requiredFixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSfixed32Value: t.expose(\\"requiredSfixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSfixed64Value: t.expose(\\"requiredSfixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredBoolValue: t.expose(\\"requiredBoolValue\\", {
            type: \\"Boolean\\",
            nullable: false
        }),
        requiredStringValue: t.expose(\\"requiredStringValue\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredDoubleValues: t.expose(\\"requiredDoubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredFloatValues: t.expose(\\"requiredFloatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt32Values: t.expose(\\"requiredInt32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt64Values: t.expose(\\"requiredInt64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint32Values: t.expose(\\"requiredUint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint64Values: t.expose(\\"requiredUint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint32Values: t.expose(\\"requiredSint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint64Values: t.expose(\\"requiredSint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed32Values: t.expose(\\"requiredFixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed64Values: t.expose(\\"requiredFixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed32Values: t.expose(\\"requiredSfixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed64Values: t.expose(\\"requiredSfixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredBoolValues: t.expose(\\"requiredBoolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: false, items: false }
        }),
        requiredStringValues: t.expose(\\"requiredStringValues\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Primitives | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Primitives\\";
    }
});
export type MessageInput$Shape = {
    requiredPrimitives: PrimitivesInput$Shape;
    optionalPrimitives?: PrimitivesInput$Shape | null;
    requiredPrimitivesList: Array<PrimitivesInput$Shape>;
    optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};
export const MessageInput$Ref = builder.inputRef<MessageInput$Shape>(\\"MessageInput\\");
MessageInput$Ref.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesInput$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesInput$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesInput$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesInput$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export type MessagePartialInput$Shape = {
    requiredPrimitives?: PrimitivesPartialInput$Shape | null;
    optionalPrimitives?: PrimitivesPartialInput$Shape | null;
    requiredPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
    optionalPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
};
export const MessagePartialInput$Ref = builder.inputRef<MessagePartialInput$Shape>(\\"MessagePartialInput\\");
MessagePartialInput$Ref.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesPartialInput$Ref,
            required: false,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesPartialInput$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesPartialInput$Ref],
            required: { list: false, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesPartialInput$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export type PrimitivesInput$Shape = {
    requiredDoubleValue: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"];
    requiredFloatValue: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"];
    requiredInt32Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"];
    requiredInt64Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"];
    requiredUint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"];
    requiredUint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"];
    requiredSint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"];
    requiredSint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"];
    requiredFixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"];
    requiredFixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"];
    requiredSfixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"];
    requiredSfixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"];
    requiredBoolValue: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"];
    requiredStringValue: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"];
    requiredDoubleValues: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"];
    requiredFloatValues: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"];
    requiredInt32Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"];
    requiredInt64Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"];
    requiredUint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"];
    requiredUint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"];
    requiredSint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"];
    requiredSint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"];
    requiredFixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"];
    requiredFixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"];
    requiredSfixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"];
    requiredSfixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"];
    requiredBoolValues: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"];
    requiredStringValues: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"];
};
export const PrimitivesInput$Ref = builder.inputRef<PrimitivesInput$Shape>(\\"PrimitivesInput\\");
PrimitivesInput$Ref.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: true
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: true, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        })
    })
});
export type PrimitivesPartialInput$Shape = {
    requiredDoubleValue?: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"] | null;
    requiredFloatValue?: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"] | null;
    requiredInt32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"] | null;
    requiredInt64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"] | null;
    requiredUint32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"] | null;
    requiredUint64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"] | null;
    requiredSint32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"] | null;
    requiredSint64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"] | null;
    requiredFixed32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"] | null;
    requiredFixed64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"] | null;
    requiredSfixed32Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"] | null;
    requiredSfixed64Value?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"] | null;
    requiredBoolValue?: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"] | null;
    requiredStringValue?: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"] | null;
    requiredDoubleValues?: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"] | null;
    requiredFloatValues?: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"] | null;
    requiredInt32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"] | null;
    requiredInt64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"] | null;
    requiredUint32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"] | null;
    requiredUint64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"] | null;
    requiredSint32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"] | null;
    requiredSint64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"] | null;
    requiredFixed32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"] | null;
    requiredFixed64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"] | null;
    requiredSfixed32Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"] | null;
    requiredSfixed64Values?: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"] | null;
    requiredBoolValues?: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"] | null;
    requiredStringValues?: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"] | null;
};
export const PrimitivesPartialInput$Ref = builder.inputRef<PrimitivesPartialInput$Shape>(\\"PrimitivesPartialInput\\");
PrimitivesPartialInput$Ref.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: false
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: false
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: false, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        })
    })
});
"
`;

exports[`simple proto file with ts-proto generates pothos DSLs: primitives/primitives.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$primitives$primitives from \\"./testapis/primitives/primitives\\";
export const Message$Ref = builder.objectRef<_$testapis$primitives$primitives.Message>(\\"Message\\");
builder.objectType(Message$Ref, {
    name: \\"Message\\",
    fields: t => ({
        requiredPrimitives: t.field({
            type: Primitives$Ref,
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitives!;
            }
        }),
        optionalPrimitives: t.expose(\\"optionalPrimitives\\", {
            type: Primitives$Ref,
            nullable: true,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [Primitives$Ref],
            nullable: { list: false, items: false },
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredPrimitivesList!;
            }
        }),
        optionalPrimitivesList: t.expose(\\"optionalPrimitivesList\\", {
            type: [Primitives$Ref],
            nullable: { list: true, items: false },
            description: \\"Optional.\\"
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Message | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Message\\";
    }
});
export const Primitives$Ref = builder.objectRef<_$testapis$primitives$primitives.Primitives>(\\"Primitives\\");
builder.objectType(Primitives$Ref, {
    name: \\"Primitives\\",
    fields: t => ({
        requiredDoubleValue: t.expose(\\"requiredDoubleValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredFloatValue: t.expose(\\"requiredFloatValue\\", {
            type: \\"Float\\",
            nullable: false
        }),
        requiredInt32Value: t.expose(\\"requiredInt32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredInt64Value: t.expose(\\"requiredInt64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredUint32Value: t.expose(\\"requiredUint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredUint64Value: t.expose(\\"requiredUint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSint32Value: t.expose(\\"requiredSint32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSint64Value: t.expose(\\"requiredSint64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredFixed32Value: t.expose(\\"requiredFixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredFixed64Value: t.expose(\\"requiredFixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredSfixed32Value: t.expose(\\"requiredSfixed32Value\\", {
            type: \\"Int\\",
            nullable: false
        }),
        requiredSfixed64Value: t.expose(\\"requiredSfixed64Value\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredBoolValue: t.expose(\\"requiredBoolValue\\", {
            type: \\"Boolean\\",
            nullable: false
        }),
        requiredStringValue: t.expose(\\"requiredStringValue\\", {
            type: \\"String\\",
            nullable: false
        }),
        requiredDoubleValues: t.expose(\\"requiredDoubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredFloatValues: t.expose(\\"requiredFloatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt32Values: t.expose(\\"requiredInt32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredInt64Values: t.expose(\\"requiredInt64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint32Values: t.expose(\\"requiredUint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredUint64Values: t.expose(\\"requiredUint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint32Values: t.expose(\\"requiredSint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSint64Values: t.expose(\\"requiredSint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed32Values: t.expose(\\"requiredFixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredFixed64Values: t.expose(\\"requiredFixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed32Values: t.expose(\\"requiredSfixed32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: false, items: false }
        }),
        requiredSfixed64Values: t.expose(\\"requiredSfixed64Values\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        }),
        requiredBoolValues: t.expose(\\"requiredBoolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: false, items: false }
        }),
        requiredStringValues: t.expose(\\"requiredStringValues\\", {
            type: [\\"String\\"],
            nullable: { list: false, items: false }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$primitives$primitives.Primitives | {
            $type: string & {};
        }).$type === \\"testapis.primitives.Primitives\\";
    }
});
export type MessageInput$Shape = {
    requiredPrimitives: PrimitivesInput$Shape;
    optionalPrimitives?: PrimitivesInput$Shape | null;
    requiredPrimitivesList: Array<PrimitivesInput$Shape>;
    optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};
export const MessageInput$Ref = builder.inputRef<MessageInput$Shape>(\\"MessageInput\\");
MessageInput$Ref.implement({
    fields: t => ({
        requiredPrimitives: t.field({
            type: PrimitivesInput$Ref,
            required: true,
            description: \\"Required.\\"
        }),
        optionalPrimitives: t.field({
            type: PrimitivesInput$Ref,
            required: false,
            description: \\"Optional.\\"
        }),
        requiredPrimitivesList: t.field({
            type: [PrimitivesInput$Ref],
            required: { list: true, items: true },
            description: \\"Required.\\"
        }),
        optionalPrimitivesList: t.field({
            type: [PrimitivesInput$Ref],
            required: { list: false, items: true },
            description: \\"Optional.\\"
        })
    })
});
export type PrimitivesInput$Shape = {
    requiredDoubleValue: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValue\\"];
    requiredFloatValue: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValue\\"];
    requiredInt32Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Value\\"];
    requiredInt64Value: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Value\\"];
    requiredUint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Value\\"];
    requiredUint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Value\\"];
    requiredSint32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Value\\"];
    requiredSint64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Value\\"];
    requiredFixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Value\\"];
    requiredFixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Value\\"];
    requiredSfixed32Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Value\\"];
    requiredSfixed64Value: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Value\\"];
    requiredBoolValue: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValue\\"];
    requiredStringValue: _$testapis$primitives$primitives.Primitives[\\"requiredStringValue\\"];
    requiredDoubleValues: _$testapis$primitives$primitives.Primitives[\\"requiredDoubleValues\\"];
    requiredFloatValues: _$testapis$primitives$primitives.Primitives[\\"requiredFloatValues\\"];
    requiredInt32Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt32Values\\"];
    requiredInt64Values: _$testapis$primitives$primitives.Primitives[\\"requiredInt64Values\\"];
    requiredUint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint32Values\\"];
    requiredUint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredUint64Values\\"];
    requiredSint32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint32Values\\"];
    requiredSint64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSint64Values\\"];
    requiredFixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed32Values\\"];
    requiredFixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredFixed64Values\\"];
    requiredSfixed32Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed32Values\\"];
    requiredSfixed64Values: _$testapis$primitives$primitives.Primitives[\\"requiredSfixed64Values\\"];
    requiredBoolValues: _$testapis$primitives$primitives.Primitives[\\"requiredBoolValues\\"];
    requiredStringValues: _$testapis$primitives$primitives.Primitives[\\"requiredStringValues\\"];
};
export const PrimitivesInput$Ref = builder.inputRef<PrimitivesInput$Shape>(\\"PrimitivesInput\\");
PrimitivesInput$Ref.implement({
    fields: t => ({
        requiredDoubleValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredFloatValue: t.field({
            type: \\"Float\\",
            required: true
        }),
        requiredInt32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredInt64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredUint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredUint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSint32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSint64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredFixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredFixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredSfixed32Value: t.field({
            type: \\"Int\\",
            required: true
        }),
        requiredSfixed64Value: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredBoolValue: t.field({
            type: \\"Boolean\\",
            required: true
        }),
        requiredStringValue: t.field({
            type: \\"String\\",
            required: true
        }),
        requiredDoubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredFloatValues: t.field({
            type: [\\"Float\\"],
            required: { list: true, items: true }
        }),
        requiredInt32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredInt64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredUint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredUint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSint64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredFixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredFixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed32Values: t.field({
            type: [\\"Int\\"],
            required: { list: true, items: true }
        }),
        requiredSfixed64Values: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        }),
        requiredBoolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: true, items: true }
        }),
        requiredStringValues: t.field({
            type: [\\"String\\"],
            required: { list: true, items: true }
        })
    })
});
"
`;

exports[`well-known protobuf types with ts-proto generates pothos DSLs: wktypes/well_known_types.pb.pothos.ts 1`] = `
"// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { builder } from \\"../../builder\\";
import * as _$testapis$wktypes$well_known_types from \\"./testapis/wktypes/well_known_types\\";
export const Message$Ref = builder.objectRef<_$testapis$wktypes$well_known_types.Message>(\\"Message\\");
builder.objectType(Message$Ref, {
    name: \\"Message\\",
    fields: t => ({
        timestamp: t.expose(\\"timestamp\\", {
            type: \\"DateTime\\",
            nullable: true
        }),
        int32Value: t.expose(\\"int32Value\\", {
            type: \\"Int\\",
            nullable: true
        }),
        int64Value: t.expose(\\"int64Value\\", {
            type: \\"String\\",
            nullable: true
        }),
        uint32Value: t.expose(\\"uint32Value\\", {
            type: \\"Int\\",
            nullable: true
        }),
        uint64Value: t.expose(\\"uint64Value\\", {
            type: \\"String\\",
            nullable: true
        }),
        floatValue: t.expose(\\"floatValue\\", {
            type: \\"Float\\",
            nullable: true
        }),
        doubleValue: t.expose(\\"doubleValue\\", {
            type: \\"Float\\",
            nullable: true
        }),
        boolValue: t.expose(\\"boolValue\\", {
            type: \\"Boolean\\",
            nullable: true
        }),
        stringValue: t.expose(\\"stringValue\\", {
            type: \\"String\\",
            nullable: true
        }),
        timestamps: t.expose(\\"timestamps\\", {
            type: [\\"DateTime\\"],
            nullable: { list: true, items: false }
        }),
        int32Values: t.expose(\\"int32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: true, items: false }
        }),
        int64Values: t.expose(\\"int64Values\\", {
            type: [\\"String\\"],
            nullable: { list: true, items: false }
        }),
        uint32Values: t.expose(\\"uint32Values\\", {
            type: [\\"Int\\"],
            nullable: { list: true, items: false }
        }),
        uint64Values: t.expose(\\"uint64Values\\", {
            type: [\\"String\\"],
            nullable: { list: true, items: false }
        }),
        floatValues: t.expose(\\"floatValues\\", {
            type: [\\"Float\\"],
            nullable: { list: true, items: false }
        }),
        doubleValues: t.expose(\\"doubleValues\\", {
            type: [\\"Float\\"],
            nullable: { list: true, items: false }
        }),
        boolValues: t.expose(\\"boolValues\\", {
            type: [\\"Boolean\\"],
            nullable: { list: true, items: false }
        }),
        stringValues: t.expose(\\"stringValues\\", {
            type: [\\"String\\"],
            nullable: { list: true, items: false }
        }),
        requiredTimestamp: t.field({
            type: \\"DateTime\\",
            nullable: false,
            description: \\"Required.\\",
            resolve: source => {
                return source.requiredTimestamp!;
            }
        })
    }),
    isTypeOf: source => {
        return (source as _$testapis$wktypes$well_known_types.Message | {
            $type: string & {};
        }).$type === \\"testapis.wktypes.Message\\";
    }
});
export type MessageInput$Shape = {
    timestamp?: _$testapis$wktypes$well_known_types.Message[\\"timestamp\\"] | null;
    int32Value?: _$testapis$wktypes$well_known_types.Message[\\"int32Value\\"] | null;
    int64Value?: _$testapis$wktypes$well_known_types.Message[\\"int64Value\\"] | null;
    uint32Value?: _$testapis$wktypes$well_known_types.Message[\\"uint32Value\\"] | null;
    uint64Value?: _$testapis$wktypes$well_known_types.Message[\\"uint64Value\\"] | null;
    floatValue?: _$testapis$wktypes$well_known_types.Message[\\"floatValue\\"] | null;
    doubleValue?: _$testapis$wktypes$well_known_types.Message[\\"doubleValue\\"] | null;
    boolValue?: _$testapis$wktypes$well_known_types.Message[\\"boolValue\\"] | null;
    stringValue?: _$testapis$wktypes$well_known_types.Message[\\"stringValue\\"] | null;
    timestamps?: _$testapis$wktypes$well_known_types.Message[\\"timestamps\\"] | null;
    int32Values?: _$testapis$wktypes$well_known_types.Message[\\"int32Values\\"] | null;
    int64Values?: _$testapis$wktypes$well_known_types.Message[\\"int64Values\\"] | null;
    uint32Values?: _$testapis$wktypes$well_known_types.Message[\\"uint32Values\\"] | null;
    uint64Values?: _$testapis$wktypes$well_known_types.Message[\\"uint64Values\\"] | null;
    floatValues?: _$testapis$wktypes$well_known_types.Message[\\"floatValues\\"] | null;
    doubleValues?: _$testapis$wktypes$well_known_types.Message[\\"doubleValues\\"] | null;
    boolValues?: _$testapis$wktypes$well_known_types.Message[\\"boolValues\\"] | null;
    stringValues?: _$testapis$wktypes$well_known_types.Message[\\"stringValues\\"] | null;
    requiredTimestamp: _$testapis$wktypes$well_known_types.Message[\\"requiredTimestamp\\"];
};
export const MessageInput$Ref = builder.inputRef<MessageInput$Shape>(\\"MessageInput\\");
MessageInput$Ref.implement({
    fields: t => ({
        timestamp: t.field({
            type: \\"DateTime\\",
            required: false
        }),
        int32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        int64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        uint32Value: t.field({
            type: \\"Int\\",
            required: false
        }),
        uint64Value: t.field({
            type: \\"String\\",
            required: false
        }),
        floatValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        doubleValue: t.field({
            type: \\"Float\\",
            required: false
        }),
        boolValue: t.field({
            type: \\"Boolean\\",
            required: false
        }),
        stringValue: t.field({
            type: \\"String\\",
            required: false
        }),
        timestamps: t.field({
            type: [\\"DateTime\\"],
            required: { list: false, items: true }
        }),
        int32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        int64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        uint32Values: t.field({
            type: [\\"Int\\"],
            required: { list: false, items: true }
        }),
        uint64Values: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        floatValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        doubleValues: t.field({
            type: [\\"Float\\"],
            required: { list: false, items: true }
        }),
        boolValues: t.field({
            type: [\\"Boolean\\"],
            required: { list: false, items: true }
        }),
        stringValues: t.field({
            type: [\\"String\\"],
            required: { list: false, items: true }
        }),
        requiredTimestamp: t.field({
            type: \\"DateTime\\",
            required: true,
            description: \\"Required.\\"
        })
    })
});
"
`;
