import {
  FileDescriptorProto,
  FieldDescriptorProto,
} from "google-protobuf/google/protobuf/descriptor_pb";
import ts from "typescript";
import { ProtoField, ProtoMessage } from "./protoTypes";

export function printSource(
  fd: FileDescriptorProto,
  msgs: ProtoMessage[],
  params: { importPrefix?: string }
): string {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const msgASTs = msgs.map((m) => new MessageAST(m, params));
  let ast: ts.Statement[] = [
    ts.factory.createImportDeclaration(
      undefined,
      undefined,
      ts.factory.createImportClause(
        false,
        undefined,
        ts.factory.createNamedImports([
          ts.factory.createImportSpecifier(
            undefined,
            ts.factory.createIdentifier("objectType")
          ),
        ])
      ),
      ts.factory.createStringLiteral("@nexus/schema")
    ),
  ];

  const unwrapFuncs = uniq(
    compact(msgASTs.flatMap((m) => m.fields.map((f) => f.unwrapFunc))),
    (f) => f.name
  );

  const imports = uniq([...unwrapFuncs.flatMap((f) => f.imports)]);
  for (const imp of imports) {
    ast.push(createImportAllWithAliastDecl(imp));
  }

  const exports = uniq([
    ...msgASTs.map((m) => ({ path: m.import, name: m.name })),
  ]);
  for (const exp of exports) {
    ast.push(createExportAllWithAliastDecl(exp));
  }

  ast = [...ast, ...msgASTs.map((m) => m.build())];

  const file = ts.factory.updateSourceFile(
    ts.createSourceFile(
      "generated.ts",
      "",
      ts.ScriptTarget.Latest,
      false,
      ts.ScriptKind.TS
    ),
    ast,
    false
  );
  const result = printer.printFile(file);

  return [
    "// Code generated by protoc-gen-nexus. DO NOT EDIT.",
    `// source: ${fd.getName()}`,
    "",
    result,
  ].join("\n");
}

class MessageAST {
  constructor(
    private readonly msg: ProtoMessage,
    private readonly params: { importPrefix?: string }
  ) {}

  get name(): string {
    return this.msg.name;
  }

  get fields(): FieldAST[] {
    return this.msg.fields.map((f) => new FieldAST(f));
  }

  get sourceTypeExpression(): ts.Expression {
    return ts.factory.createObjectLiteralExpression([
      ts.factory.createPropertyAssignment(
        "module",
        ts.factory.createIdentifier("__filename")
      ),
      ts.factory.createPropertyAssignment(
        "export",
        ts.factory.createStringLiteral(
          uniqueImportAlias(`${this.import}/${this.name}`)
        )
      ),
    ]);
  }

  get import(): string {
    const { importPrefix } = this.params;
    return `${importPrefix ? `${importPrefix}/` : "./"}${this.msg.importPath}`;
  }

  get importDecl(): ts.ImportDeclaration {
    return createImportAllWithAliastDecl(this.import);
  }

  public build(): ts.Statement {
    return ts.factory.createVariableStatement(
      [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createVariableDeclarationList(
        [
          ts.factory.createVariableDeclaration(
            this.name,
            undefined,
            undefined,
            this.buildObjectType()
          ),
        ],
        ts.NodeFlags.Const
      )
    );
  }

  private buildObjectType(): ts.Expression {
    const { name, description } = this.msg;

    return ts.factory.createCallExpression(
      ts.factory.createIdentifier("objectType"),
      undefined,
      [
        ts.factory.createObjectLiteralExpression(
          [
            ts.factory.createPropertyAssignment(
              "name",
              ts.factory.createStringLiteral(name)
            ),
            ts.factory.createPropertyAssignment(
              "description",
              ts.factory.createStringLiteral(description)
            ),
            // TODO: "description" property
            ts.factory.createMethodDeclaration(
              undefined,
              undefined,
              undefined,
              "definition",
              undefined,
              undefined,
              [
                ts.factory.createParameterDeclaration(
                  undefined,
                  undefined,
                  undefined,
                  "t",
                  undefined,
                  undefined,
                  undefined
                ),
              ],
              undefined,
              ts.factory.createBlock(
                this.fields.map((f) => f.build()),
                true
              )
            ),
            ts.factory.createPropertyAssignment(
              "sourceType",
              this.sourceTypeExpression
            ),
          ],
          true
        ),
      ]
    );
  }
}

class FieldAST {
  private readonly field: ProtoField;
  private readonly type: Type;

  constructor(field: ProtoField) {
    this.field = field;
    this.type = convertType(field);
  }

  public build(): ts.Statement {
    const { name } = this.field;

    return ts.factory.createExpressionStatement(
      ts.factory.createCallExpression(this.fieldFunction, undefined, [
        ts.factory.createStringLiteral(name),
        this.options,
      ])
    );
  }

  get unwrapFunc(): UnwrapFunc | null {
    return unwrapFuncs[this.field.protoTypeName] || null;
  }

  private get fieldFunction(): ts.Expression {
    let left: ts.Expression = ts.factory.createIdentifier("t");

    left = ts.factory.createPropertyAccessExpression(
      left,
      ts.factory.createIdentifier(
        this.field.isNullable() ? "nullable" : "nonNull"
      )
    );

    if (this.type.kind === "list") {
      left = ts.factory.createPropertyAccessExpression(
        left,
        ts.factory.createIdentifier("list")
      );
    }

    return ts.factory.createPropertyAccessExpression(
      left,
      ts.factory.createIdentifier(this.nexusTypeName)
    );
  }

  private get nexusTypeName(): string {
    const { type } = this;

    switch (type.kind) {
      case "list":
        return "field";
      case "scalar":
        switch (type.type) {
          case "Int":
            return "int";
          case "Float":
            return "float";
          case "String":
            return "string";
          case "Boolean":
            return "boolean";
          case "ID":
            return "id";
          case "DateTime":
            return "dateTime";
          default:
            const _exhaustiveCheck: never = type; // eslint-disable-line
            throw "unreachable";
        }
      case "object":
        return "field";
      default:
        const _exhaustiveCheck: never = type; // eslint-disable-line
        throw "unreachable";
    }
  }

  private get options(): ts.ObjectLiteralExpression {
    const { type } = this;
    const { getterName, description } = this.field;
    const props: ts.ObjectLiteralElementLike[] = [
      ts.factory.createPropertyAssignment(
        "description",
        ts.factory.createStringLiteral(description)
      ),
    ];

    if (type.kind === "list") {
      props.push(
        ts.factory.createPropertyAssignment(
          "type",
          ts.factory.createStringLiteral(type.type.type)
        )
      );
    }

    if (type.kind === "object") {
      props.push(
        ts.factory.createPropertyAssignment(
          "type",
          ts.factory.createStringLiteral(type.type)
        )
      );
    }

    let resolverRet: ts.Expression = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
        ts.factory.createIdentifier("root"),
        ts.factory.createIdentifier(getterName)
      ),
      undefined,
      undefined
    );
    if (this.unwrapFunc !== null) {
      resolverRet = ts.factory.createCallExpression(
        ts.factory.createIdentifier(this.unwrapFunc.name),
        undefined,
        [resolverRet]
      );
    }

    props.push(
      ts.factory.createMethodDeclaration(
        undefined,
        undefined,
        undefined,
        "resolve",
        undefined,
        undefined,
        [
          ts.factory.createParameterDeclaration(
            undefined,
            undefined,
            undefined,
            "root",
            undefined,
            undefined,
            undefined
          ),
        ],
        undefined,
        ts.factory.createBlock([ts.factory.createReturnStatement(resolverRet)])
      )
    );

    return ts.factory.createObjectLiteralExpression(props, true);
  }
}

function compact<T>(input: T[]): NonNullable<T>[] {
  return input.filter((v): v is NonNullable<T> => v != null);
}

function uniq<T, V>(input: T[], f?: (t: T) => V) {
  const out = [] as T[];
  const set = new Set<T | V>();

  for (const v of input) {
    const key = f ? f(v) : v;
    if (!set.has(key)) {
      set.add(key);
      out.push(v);
    }
  }

  return out;
}

function uniqueImportAlias(path: string) {
  return path
    .replace(/@/g, "$$$$")
    .replace(/\.\.\//g, "__$$")
    .replace(/\.\//g, "_$$")
    .replace(/\//g, "$$")
    .replace(/-/g, "_");
}

type UnwrapFunc = {
  imports: string[];
  name: string;
};

const unwrapFuncs: Record<string, UnwrapFunc> = {
  ".google.protobuf.Int32Value": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapInt32Value`,
  },
  ".google.protobuf.UInt32Value": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapUInt32Value`,
  },
  ".google.protobuf.Int64Value": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapInt64Value`,
  },
  ".google.protobuf.UInt64Value": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapUInt64Value`,
  },
  ".google.protobuf.FloatValue": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapFloatValue`,
  },
  ".google.protobuf.DoubleValue": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapDoubleValue`,
  },
  ".google.protobuf.StringValue": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapStringValue`,
  },
  ".google.protobuf.BoolValue": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.unwrapBoolValue`,
  },
  ".google.protobuf.Timestamp": {
    imports: ["proto-nexus"],
    name: `${uniqueImportAlias("proto-nexus")}.timestampToDate`,
  },
};

function createImportAllWithAliastDecl(path: string): ts.ImportDeclaration {
  return ts.factory.createImportDeclaration(
    undefined,
    undefined,
    ts.factory.createImportClause(
      false,
      undefined,
      ts.factory.createNamespaceImport(
        ts.factory.createIdentifier(uniqueImportAlias(path))
      )
    ),
    ts.factory.createStringLiteral(path)
  );
}

function createExportAllWithAliastDecl({
  path,
  name,
}: {
  path: string;
  name: string;
}): ts.ExportDeclaration {
  return ts.factory.createExportDeclaration(
    undefined,
    undefined,
    false,
    ts.factory.createNamedExports([
      ts.factory.createExportSpecifier(
        name,
        uniqueImportAlias(`${path}/${name}`)
      ),
    ]),
    ts.factory.createStringLiteral(path)
  );
}

type ScalarType = "Int" | "Float" | "String" | "Boolean" | "ID" | "DateTime";

export type ItemType =
  | {
      kind: "scalar";
      type: ScalarType;
    }
  | {
      kind: "object";
      type: string;
    };

export type Type =
  | ItemType
  | {
      kind: "list";
      type: ItemType;
    };

function convertType(f: ProtoField): Type {
  if (f.isList()) {
    return {
      kind: "list",
      type: convertItemType(f),
    };
  }

  return convertItemType(f);
}

function convertItemType(f: ProtoField): ItemType {
  const pbtype = f.descriptor.getType()!;
  switch (pbtype) {
    case FieldDescriptorProto.Type.TYPE_STRING:
      return { kind: "scalar", type: "String" };
    case FieldDescriptorProto.Type.TYPE_DOUBLE:
    case FieldDescriptorProto.Type.TYPE_FLOAT:
      return { kind: "scalar", type: "Float" };
    case FieldDescriptorProto.Type.TYPE_INT64:
    case FieldDescriptorProto.Type.TYPE_UINT64:
    case FieldDescriptorProto.Type.TYPE_INT32:
    case FieldDescriptorProto.Type.TYPE_FIXED64:
    case FieldDescriptorProto.Type.TYPE_FIXED32:
    case FieldDescriptorProto.Type.TYPE_UINT32:
    case FieldDescriptorProto.Type.TYPE_SFIXED32:
    case FieldDescriptorProto.Type.TYPE_SFIXED64:
    case FieldDescriptorProto.Type.TYPE_SINT32:
    case FieldDescriptorProto.Type.TYPE_SINT64:
      return { kind: "scalar", type: "Int" };
    case FieldDescriptorProto.Type.TYPE_BOOL:
      return { kind: "scalar", type: "Boolean" };
    case FieldDescriptorProto.Type.TYPE_GROUP:
      throw "not supported";
    case FieldDescriptorProto.Type.TYPE_BYTES:
      throw "not supported";
    case FieldDescriptorProto.Type.TYPE_ENUM:
      throw "not implemented";
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
      switch (f.descriptor.getTypeName()) {
        case ".google.protobuf.Any":
          throw "not supported";
        case ".google.protobuf.BoolValue":
          return {
            kind: "scalar",
            type: "Boolean",
          };
        case ".google.protobuf.BytesValue":
          throw "not supported";
        case ".google.protobuf.DoubleValue":
        case ".google.protobuf.FloatValue":
          return {
            kind: "scalar",
            type: "Float",
          };
        case ".google.protobuf.Duration":
          throw "not implemented";
        case ".google.protobuf.Int32Value":
        case ".google.protobuf.Int64Value":
        case ".google.protobuf.UInt32Value":
        case ".google.protobuf.UInt64Value":
          return {
            kind: "scalar",
            type: "Int",
          };
        case ".google.protobuf.StringValue":
          return {
            kind: "scalar",
            type: "String",
          };
        case ".google.protobuf.Timestamp":
          return {
            kind: "scalar",
            type: "DateTime",
          };
        default:
          return {
            kind: "object",
            // FIXME
            type: f.descriptor.getTypeName()!.split(".").slice(-1)[0]!,
          };
      }
    default:
      const _exhaustiveCheck: never = pbtype; // eslint-disable-line
      throw "unreachable";
  }
}
